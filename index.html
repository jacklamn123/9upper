<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>9upper Online</title>

    <!-- ✅ Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .hidden {
            display: none;
        }
        .chatbox {
    width: 300px;
    height: 200px;
    border: 1px solid black;
    overflow-y: auto; /* ✅ Enables scrolling */
    margin: 10px auto;
    text-align: left;
    padding: 5px;
    background-color: #f0f0f0;
    display: flex;
    flex-direction: column; /* ✅ Ensures messages fill height */
}

#chatMessages {
    flex-grow: 1; /* ✅ Makes sure messages fill the chatbox */
    overflow-y: auto; /* ✅ Allows scrolling */
}
        /* ✅ Scoreboard Styling */
/* ✅ Scoreboard Styling */
#scoreboard {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: #ffffff;
    border: 2px solid black;
    padding: 10px;
    width: 220px; /* ✅ Slightly wider for better alignment */
    font-size: 14px;
    text-align: center;
}

#scoreboard table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed; /* ✅ Ensure equal column width */
}

#scoreboard th, #scoreboard td {
    border: 1px solid black;
    padding: 5px;
    text-align: center;
    width: 33.33%; /* ✅ Make sure all columns have the same width */
    word-break: break-word; /* ✅ Prevent long names from breaking layout */
}

#scoreboard th {
    background-color: #f2f2f2;
}
        /* ✅ Positioning Buttons Near the Scoreboard */
#returnToMainMenu {
    position: absolute;
    top: 10px;
    left: 250px; /* ✅ Adjusted next to the scoreboard */
    background-color: red;
    color: white;
    padding: 8px 15px;
    border: none;
    cursor: pointer;
}

#forceReturnToWaitingRoom {
    position: absolute;
    top: 50px;
    left: 250px;
    background-color: blue;
    color: white;
    padding: 8px 15px;
    border: none;
    cursor: pointer;
}




    </style>

    <script>
        // ✅ Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB1PPLZl8380-xEpyVX3z8ya9eRji2H-uk",
            authDomain: "upper-2c864.firebaseapp.com",
            databaseURL: "https://upper-2c864-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "upper-2c864",
            storageBucket: "upper-2c864.firebasestorage.app",
            messagingSenderId: "1065732661608",
            appId: "1:1065732661608:web:2db40ab8d60697b34f6dd",
            measurementId: "G-F348XKS47Q"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        var gameCode = ""; 
        var playerName = "";

        function confirmName() {
            playerName = document.getElementById("playerNameInput").value.trim();
            if (playerName === "") {
                alert("Please enter a valid name!");
                return;
            }
            document.getElementById("nameInput").classList.add("hidden");
            document.getElementById("setupArea").classList.remove("hidden");
        }

   

function createGame() {
    gameCode = Math.random().toString(36).substr(2, 6).toUpperCase();
    var totalRounds = document.getElementById("roundsSlider").value;
    var roundTime = document.getElementById("timeSlider").value;

    db.ref("games/" + gameCode).set({
        status: "waiting",
        players: {},
        host: playerName,
        chat: {},
        totalRounds: totalRounds,  // ✅ Store total rounds
        roundTime: roundTime       // ✅ Store time per round
    }).then(() => {
        document.getElementById("gameCodeDisplay").innerText = gameCode;
        document.getElementById("setupArea").classList.add("hidden");
        document.getElementById("gameArea").classList.remove("hidden");
        db.ref("games/" + gameCode + "/players/" + playerName).set(true);
        listenForUpdates();
    });
}


        function joinGame() {
            gameCode = document.getElementById("gameCodeInput").value.toUpperCase();
            if (!gameCode) {
                alert("Please enter a valid game code!");
                return;
            }
            db.ref("games/" + gameCode).get().then(snapshot => {
                if (snapshot.exists()) {
                    document.getElementById("gameCodeDisplay").innerText = gameCode;
                    document.getElementById("setupArea").classList.add("hidden");
                    document.getElementById("gameArea").classList.remove("hidden");
                    db.ref("games/" + gameCode + "/players/" + playerName).set(true);
                    listenForUpdates();
                } else {
                    alert("Game not found!");
                }
            });
        }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////LISTENFORUPDATE////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function listenForUpdates() {
    db.ref("games/" + gameCode).on("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        // ✅ Update player list in the waiting room
        if (gameData.players) {
            var playerList = Object.keys(gameData.players)
                .map(name => `<li>${name}</li>`).join("");
            document.getElementById("playerList").innerHTML = `<ul>${playerList}</ul>`;

            document.getElementById("roundsValue").innerText = gameData.totalRounds;
            document.getElementById("timeValue").innerText = gameData.roundTime;

            if (gameData.host === playerName) {
                document.getElementById("gameSettings").classList.remove("hidden");
                document.getElementById("startGameButton").classList.remove("hidden");
            }
        }

        // ✅ Auto-update scoreboard when scores change
        if (gameData.scores) {
            updateScoreboard(gameData.scores);
        }

        // ✅ Chatbox Auto-Scrolling
        if (gameData.chat) {
            const chatBox = document.querySelector(".chatbox");

            // Clear existing messages
            chatBox.innerHTML = "";

            // Add all messages
            Object.values(gameData.chat).forEach(msg => {
                chatBox.innerHTML += `<p>${msg}</p>`;
            });

            // ✅ Ensure chatbox is visible
            chatBox.style.display = "block";

            // ✅ Force scroll to the bottom
            setTimeout(() => {
                chatBox.scrollTop = chatBox.scrollHeight;
            }, 100);
        }

        // ✅ Handle game state: Playing
if (gameData.status === "playing") {
    document.getElementById("waitingRoom").classList.add("hidden");
    document.getElementById("gameScreen").classList.remove("hidden");

    document.getElementById("gameTerm").innerText = gameData.term;
    document.getElementById("playerRole").innerText = gameData.roles[playerName];

    document.getElementById("currentRoundDisplay").innerText = gameData.currentRound;
    document.getElementById("totalRoundsDisplay").innerText = gameData.totalRounds;

    // ✅ Host starts the countdown timer
    if (gameData.host === playerName) {
        startCountdown(gameData.timeLeft, gameData.currentRound, gameData.totalRounds, gameData.roundTime);
    }

    // ✅ Update time left
    document.getElementById("timeLeftDisplay").innerText = gameData.timeLeft + " seconds";

    // ✅ Hide thinker panel unless needed
    document.getElementById("thinkerPanel").classList.add("hidden");

    // ✅ Show definition only for REALUPPER
    const definitionBox = document.getElementById("correctDefinitionBox");
    const definitionText = document.getElementById("correctDefinition");

    if (definitionBox && definitionText) {
        if (gameData.roles[playerName] === "REALUPPER") {
            definitionText.innerText = gameData.correctDefinition;
            definitionBox.classList.remove("hidden");
        } else {
            definitionBox.classList.add("hidden");
            definitionText.innerText = "";  // ✅ Clear previous round’s definition
        }
    }

    // ✅ Ensure 9UPPER players don’t see the definition
    const definitionInputBox = document.getElementById("definitionInputBox");
    if (definitionInputBox) {
        if (gameData.roles[playerName] === "9UPPER") {
            definitionInputBox.classList.remove("hidden");
        } else {
            definitionInputBox.classList.add("hidden");
        }
    }

    displaythinkerOptions(gameData);

    // ✅ Show "Return to Waiting Room" only for the host
    const returnToWaitingRoomBtn = document.getElementById("forceReturnToWaitingRoom");
    if (returnToWaitingRoomBtn) {
        if (gameData.host === playerName) {
            returnToWaitingRoomBtn.classList.remove("hidden");
        } else {
            returnToWaitingRoomBtn.classList.add("hidden");
        }
    }

}
// ✅ Add this new block for status === "waiting"
else if (gameData.status === "waiting") {
    // Hide the game screen, show the waiting room
    document.getElementById("gameScreen").classList.add("hidden");
    document.getElementById("waitingRoom").classList.remove("hidden");

    // Hide the "Return to Waiting Room" button for everyone
    const returnToWaitingRoomBtn = document.getElementById("forceReturnToWaitingRoom");
    if (returnToWaitingRoomBtn) {
        returnToWaitingRoomBtn.classList.add("hidden");
    }
}
// Anything else (not playing, not waiting)
else {
    // If game is NOT playing or waiting, ensure "Return to Waiting Room" is hidden
    const returnToWaitingRoomBtn = document.getElementById("forceReturnToWaitingRoom");
    if (returnToWaitingRoomBtn) {
        returnToWaitingRoomBtn.classList.add("hidden");
    }
}


        // ✅ Always show "Return to Main Menu" button (for all players)
        const returnToMainMenuBtn = document.getElementById("returnToMainMenu");
        if (returnToMainMenuBtn) {
            returnToMainMenuBtn.classList.remove("hidden");
        }

        // ✅ Handle game end
       if (gameData.status === "finished") {
    // ✅ Immediately set status to something else (like "post-finished")
    db.ref("games/" + gameCode).update({ status: "post-finished" });
    showEndgameScreen(gameData.scores);
}

    });
}

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////LISTENFORUPDATE////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        





        





        var roundTimer; // ✅ Global timer variable

function startCountdown(timeLeft, round, totalRounds, roundTime) {
    if (isNaN(timeLeft) || timeLeft === undefined) {
        console.error("Error: timeLeft is NaN or undefined, resetting to 60");
        timeLeft = 60;
    }

    clearInterval(roundTimer);

    roundTimer = setInterval(() => {
        if (timeLeft <= 0) {
            clearInterval(roundTimer);
            db.ref("games/" + gameCode).update({ timeLeft: 0 });

            if (round >= totalRounds) {
                endRound(round, totalRounds);
            } else {
                db.ref("games/" + gameCode).once("value", snapshot => {
                    var gameData = snapshot.val();
                    if (!gameData) return;

                    var nextRound = (gameData.currentRound || 0) + 1;
                    fetch("9upper_terms.json")
                        .then(response => response.json())
                        .then(terms => {
                            startNewRound(terms, nextRound, totalRounds, roundTime);
                        });
                });
            }
        } else {
            timeLeft--;
            db.ref("games/" + gameCode).update({ timeLeft: timeLeft });

            document.getElementById("timeLeftDisplay").innerText = timeLeft + " seconds";
        }
    }, 1000);
}





        
function displaythinkerOptions(gameData) {
    var thinker = Object.keys(gameData.players).find(p => gameData.roles[p] === "thinker");
    var playerRole = gameData.roles[playerName];

    if (playerRole === "thinker") {
        // ✅ Show thinker panel only if the player is the thinker
        document.getElementById("thinkerPanel").classList.remove("hidden");

        var selectablePlayers = Object.keys(gameData.players).filter(p => p !== thinker);

        var buttonsHTML = selectablePlayers.map(player =>
            `<button onclick="thinkerSelectPlayer('${player}')">${player}</button>`
        ).join(" ");

        document.getElementById("thinkerOptions").innerHTML = buttonsHTML;
    } 
    else if (playerRole === "REALUPPER" || playerRole === "9UPPER") {
        // ✅ Explicitly hide panel for REALUPPER & 9UPPER players
        document.getElementById("thinkerPanel").classList.add("hidden");
        document.getElementById("thinkerOptions").innerHTML = ""; // Clear buttons
    }
}







function thinkerSelectPlayer(selectedPlayer) {
    clearInterval(roundTimer);

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        var scores = gameData.scores || {};
        var roles = gameData.roles || {};
        var thinker = Object.keys(roles).find(p => roles[p] === "thinker");
        var realUpper = Object.keys(roles).find(p => roles[p] === "REALUPPER");

        if (selectedPlayer === realUpper) {
            scores[thinker] = (scores[thinker] || 0) + 1;
            scores[realUpper] = (scores[realUpper] || 0) + 1;
        } else {
            scores[selectedPlayer] = (scores[selectedPlayer] || 0) + 1;
        }

        db.ref("games/" + gameCode).update({
            scores: scores,
            winner: selectedPlayer,
            timeLeft: 0
        }).then(() => {
            updateScoreboard(scores);
        });

        db.ref("games/" + gameCode + "/currentRound").once("value", snapshot => {
            var round = snapshot.val();
            db.ref("games/" + gameCode + "/totalRounds").once("value", totalSnapshot => {
                var totalRounds = totalSnapshot.val();

                if (round >= totalRounds) {
                    endRound(round, totalRounds);
                } else {
                    fetch("9upper_terms.json")
                        .then(response => response.json())
                        .then(terms => {
                            startNewRound(terms, round + 1, totalRounds, gameData.roundTime);
                        });
                }
            });
        });
    });
}








function startGame() {
    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        var totalRounds = gameData.totalRounds;
        var roundTime = gameData.roundTime;

        fetch("9upper_terms.json")
            .then(response => response.json())
            .then(terms => {
                db.ref("games/" + gameCode + "/players").once("value", playerSnapshot => {
                    var players = Object.keys(playerSnapshot.val());
                    if (players.length < 3) {
                        alert("At least 3 players are needed to start the game!");
                        return;
                    }

                    var thinker = players[Math.floor(Math.random() * players.length)];
                    var correctPlayer = players.filter(p => p !== thinker)[Math.floor(Math.random() * (players.length - 1))];

                    var roles = {};
                    players.forEach(p => roles[p] = "9UPPER");
                    roles[thinker] = "thinker";
                    roles[correctPlayer] = "REALUPPER";

                    var randomIndex = Math.floor(Math.random() * terms.length);
                    var randomTerm = terms[randomIndex].term;
                    var correctDefinition = terms[randomIndex].definition;

                    // ✅ Initialize scores for all players
                    var initialScores = {};
                    players.forEach(p => initialScores[p] = 0); 

                    db.ref("games/" + gameCode).update({
                        status: "playing",
                        term: randomTerm,
                        correctDefinition: correctDefinition,
                        roles: roles,
                        currentRound: 1,
                        totalRounds: totalRounds,
                        roundTime: roundTime,
                        scores: initialScores // ✅ Store initial scores in Firebase
                    });

                    startNewRound(terms, 1, totalRounds, roundTime);
                });
            })
            .catch(error => console.error("Error loading terms:", error));
    });
}

          var roundTimer;

function startNewRound(terms, round, totalRounds, roundTime) {
    // ✅ Ensure roundTime is always valid
    if (isNaN(roundTime) || roundTime === undefined) {
        console.error("Error: roundTime is NaN or undefined, resetting to 60");
        roundTime = 60;  // ✅ Default to 60 seconds if undefined
    }

    // ✅ Ensure round is a valid number
    if (isNaN(round) || round === undefined) {
        console.error("Error: round is NaN or undefined, resetting to 1");
        round = 1;
    }

    db.ref("games/" + gameCode + "/players").once("value", snapshot => {
        var players = Object.keys(snapshot.val() || {});
        if (players.length < 3) return;

        var thinker = players[Math.floor(Math.random() * players.length)];
        var correctPlayer = players.filter(p => p !== thinker)[Math.floor(Math.random() * (players.length - 1))];

        var roles = {};
        players.forEach(p => roles[p] = "9UPPER");
        roles[thinker] = "thinker";
        roles[correctPlayer] = "REALUPPER";

        var randomIndex = Math.floor(Math.random() * terms.length);
        var randomTerm = terms[randomIndex].term;
        var correctDefinition = terms[randomIndex].definition;

        db.ref("games/" + gameCode).update({
            currentRound: round,
            term: randomTerm,
            correctDefinition: "",  // ✅ Reset before assigning a new value
            roles: roles,
            timeLeft: roundTime  // ✅ Ensure it's always a number
        }).then(() => {
            db.ref("games/" + gameCode).update({
                correctDefinition: correctDefinition // ✅ Now set the correct definition for the new REALUPPER
            });
        });

        var roundDisplay = document.getElementById("currentRoundDisplay");
        if (roundDisplay) {
            roundDisplay.innerText = round;
        }

        startRoundTimer(roundTime, round, totalRounds);
    });
}






function startRoundTimer(roundTime, round, totalRounds) {
    clearInterval(roundTimer); // ✅ Stop any existing timer

    db.ref("games/" + gameCode).update({ timeLeft: roundTime }); // ✅ Ensure Firebase starts at the right time

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        if (playerName === gameData.host) {  // ✅ Only the host updates Firebase
            roundTimer = setInterval(() => {
                db.ref("games/" + gameCode).once("value", snapshot => {
                    var gameData = snapshot.val();
                    if (!gameData) return;

                    var timeLeft = gameData.timeLeft || 0;

                    if (timeLeft <= 0) {  
                        clearInterval(roundTimer);
                        if (!gameData.winner) {  
                            db.ref("games/" + gameCode).update({ winner: "timeout" }); // ✅ Mark timeout
                        }
                        endRound(round, totalRounds); // ✅ Start next round
                    } else {
                        db.ref("games/" + gameCode).update({ timeLeft: timeLeft - 1 });
                    }
                });
            }, 1000);
        }
    });
}






function endRound(round, totalRounds) {
    clearInterval(roundTimer); // ✅ Stop any running timer

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        var roundTime = gameData.roundTime; // ✅ Fetch roundTime before calling startNewRound()

        if (round >= totalRounds) {
            db.ref("games/" + gameCode).update({ status: "finished" });

            // ✅ Ensure all players receive the endgame screen
            // showEndgameScreen(gameData.scores);
        } else {
            fetch("9upper_terms.json")
                .then(response => response.json())
                .then(terms => {
                    db.ref("games/" + gameCode).update({
                        term: "",
                        correctDefinition: "",
                        roles: {},
                        winner: null,
                        timeLeft: roundTime
                    }).then(() => {
                        startNewRound(terms, round + 1, totalRounds, roundTime);
                    });
                });
        }
    });
}








function sendChatMessage() {
    var message = $("#chatInput").val().trim(); // ✅ Use jQuery for input field
    if (message === "") return;

    db.ref("games/" + gameCode + "/chat").push(playerName + ": " + message).then(() => {
        var chatBox = $("#chatMessages"); // ✅ Use jQuery for chatbox

        // ✅ Smooth auto-scroll using jQuery
        chatBox.animate({
            scrollTop: chatBox.prop("scrollHeight")  // ✅ Correct usage
        }, 1000);
    });

    $("#chatInput").val(""); // ✅ Clear input field using jQuery
}




function updateRounds() {
    document.getElementById("roundsValue").innerText = document.getElementById("roundsSlider").value;
}

function updateTime() {
    document.getElementById("timeValue").innerText = document.getElementById("timeSlider").value;
}

   function updateScoreboard(scores) {
    var scoreboardBody = document.getElementById("scoreboardBody");
    scoreboardBody.innerHTML = ""; // Clear current scoreboard

    // Convert scores object into an array and sort by score (descending)
    var sortedPlayers = Object.entries(scores).sort((a, b) => b[1] - a[1]);

    sortedPlayers.forEach((player, index) => {
        var row = `<tr>
            <td>${index + 1}</td>
            <td style="max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${player[0]}</td>
            <td>${player[1]}</td>
        </tr>`;
        scoreboardBody.innerHTML += row;
    });
}


  // ✅ Global timer variable
var roundTimer;


        function handleGameEnd() {
    db.ref("games/" + gameCode).update({ status: "finished" });
}


function showEndgameScreen(scores) {
    // ✅ If the endGameModal already exists, do nothing
    if (document.getElementById("endGameModal")) {
        console.log("Endgame screen already shown. Not firing again.");
        return;
    }

    var endGameModal = document.createElement("div");
    endGameModal.id = "endGameModal";
    endGameModal.style.position = "fixed";
    endGameModal.style.top = "50%";
    endGameModal.style.left = "50%";
    endGameModal.style.transform = "translate(-50%, -50%)";
    endGameModal.style.background = "white";
    endGameModal.style.padding = "20px";
    endGameModal.style.borderRadius = "10px";
    endGameModal.style.boxShadow = "0 0 10px rgba(0,0,0,0.3)";
    endGameModal.style.textAlign = "center";

    var sortedScores = Object.entries(scores).sort((a, b) => b[1] - a[1]);

    var scoreHTML = `<h2>Game Over!</h2><h3>Final Scores</h3>
        <table border="1" style="margin:auto;">
        <tr><th>Rank</th><th>Player</th><th>Score</th></tr>`;

    sortedScores.forEach((player, index) => {
        scoreHTML += `<tr><td>${index + 1}</td><td>${player[0]}</td><td>${player[1]}</td></tr>`;
    });

    scoreHTML += `</table><br>`;

    endGameModal.innerHTML = scoreHTML + `
        <button onclick="returnToWaitingRoom()" style="background:blue;color:white;padding:10px;border:none;margin:5px;">Back to Waiting Room</button>
        <button onclick="returnToMainMenu()" style="background:red;color:white;padding:10px;border:none;margin:5px;">Back to Main Menu</button>
    `;

    document.body.appendChild(endGameModal);

    // Remove players from the waiting room when the game ends
    db.ref("games/" + gameCode + "/players").once("value", snapshot => {
        var players = snapshot.val();
        if (players) {
            Object.keys(players).forEach(player => {
                db.ref("games/" + gameCode + "/players/" + player).remove();
            });
        }
    });
}








function returnToWaitingRoom() {
    // ✅ Check if the modal exists before removing
    document.getElementById("endGameModal").remove();

    // ✅ Hide Game Screen & Show Waiting Room
    document.getElementById("gameScreen").classList.add("hidden");
    document.getElementById("waitingRoom").classList.remove("hidden");

    // ✅ Update Firebase: Set game status to "waiting"
    db.ref("games/" + gameCode).update({ status: "waiting" });

    // ✅ Re-add the player to the waiting room
    db.ref("games/" + gameCode + "/players/" + playerName).set(true);
}






function returnToMainMenu() {
    // If the endGameModal is on the screen, remove it.
    const endGameModal = document.getElementById("endGameModal");
    if (endGameModal) {
        endGameModal.remove();
    }

    // Remove the current player from the game so they don’t stay in the “players” list.
    db.ref("games/" + gameCode + "/players/" + playerName).remove();

    // Reload the page to show the main menu (index.html, for instance).
    window.location.reload();
}


function forceReturnToWaitingRoom() {
  console.log("Forcing all players back to the waiting room...");

  // Update game status to waiting
  db.ref("games/" + gameCode).update({ status: "waiting" });


  // Host immediately hides the game UI
  document.getElementById("gameScreen").classList.add("hidden");
  document.getElementById("waitingRoom").classList.remove("hidden");

  // Hide the button
  document.getElementById("forceReturnToWaitingRoom").classList.add("hidden");
}


        
    </script>
</head>
<body>
    <h1>9upper Online Multiplayer</h1>

    <div id="nameInput">
        <input type="text" id="playerNameInput" placeholder="Enter Your Name">
        <button onclick="confirmName()">Continue</button>
    </div>

    <div id="setupArea" class="hidden">
        <button onclick="createGame()">Create Game</button>
        <input type="text" id="gameCodeInput" placeholder="Enter Game Code">
        <button onclick="joinGame()">Join Game</button>
    </div>

    <div id="gameArea" class="hidden">
        <h2>Game Code: <span id="gameCodeDisplay"></span></h2>

        <div id="waitingRoom">
            <h2>Players in Room</h2>
            <div id="playerList"></div>
<!-- ✅ Game Settings for Host -->
<div id="gameSettings" class="hidden">
    <h3>Game Settings</h3>

    <label for="roundsSlider">Rounds: <span id="roundsValue">5</span></label>
    <input type="range" id="roundsSlider" min="5" max="20" step="5" value="5" oninput="updateRounds()">

    <br>

    <label for="timeSlider">Time per Round (seconds): <span id="timeValue">60</span></label>
    <input type="range" id="timeSlider" min="60" max="600" step="30" value="60" oninput="updateTime()">
</div>

            <button id="startGameButton" class="hidden" onclick="startGame()">Start Game</button>
        </div>

<!-- ✅ Scoreboard Display -->
<div id="scoreboard">
    <h3>Scoreboard</h3>
    <table>
        <thead>
            <tr>
                <th>Rank</th>
                <th>Player</th>
                <th>Score</th>
            </tr>
        </thead>
        <tbody id="scoreboardBody">
            <!-- Scores will be dynamically inserted here -->
        </tbody>
    </table>
</div>

        
        
<div id="gameScreen" class="hidden">
    <h3>Round <span id="currentRoundDisplay"></span> / <span id="totalRoundsDisplay"></span></h3>
    <h3>Time Remaining: <span id="timeLeftDisplay">--</span></h3>
    <h3>Term: <span id="gameTerm"></span></h3>
    <h3>Your Role: <span id="playerRole"></span></h3>

    <div id="correctDefinitionBox" class="hidden">
        <h3>REALUPPER: <span id="correctDefinition"></span></h3>
    </div>

    <div id="thinkerPanel" class="hidden">
        <h3>thinker: Pick the correct player</h3>
        <div id="thinkerOptions"></div>
    </div>
</div>





        <!-- ✅ Chatbox Added -->
        <div class="chatbox">
            <div id="chatMessages"></div>
        </div>
        <input type="text" id="chatInput" placeholder="Type a message">
        <button onclick="sendChatMessage()">Send</button>

        <!-- ✅ Scoreboard Display with New Buttons -->
<div id="scoreboard">
    <h3>Scoreboard</h3>
    <table>
        <thead>
            <tr>
                <th>Rank</th>
                <th>Player</th>
                <th>Score</th>
            </tr>
        </thead>
        <tbody id="scoreboardBody">
            <!-- Scores will be dynamically inserted here -->
        </tbody>
    </table>
</div>

<!-- ✅ Return to Main Menu Button (Visible to Everyone) -->
<button id="returnToMainMenu" onclick="returnToMainMenu()">Return to Main Menu</button>

<!-- ✅ Force Return to Waiting Room (Only for Host) -->
<button id="forceReturnToWaitingRoom" class="hidden" onclick="forceReturnToWaitingRoom()">Return to Waiting Room</button>


    </div>

    
</body>
</html>
