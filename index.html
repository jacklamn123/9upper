<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>9upper Online</title>

    <!-- ✅ Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .hidden {
            display: none;
        }
        .chatbox {
    width: 300px;
    height: 200px;
    border: 1px solid black;
    overflow-y: auto; /* ✅ Enables scrolling */
    margin: 10px auto;
    text-align: left;
    padding: 5px;
    background-color: #f0f0f0;
    display: flex;
    flex-direction: column; /* ✅ Ensures messages fill height */
}

#chatMessages {
    flex-grow: 1; /* ✅ Makes sure messages fill the chatbox */
    overflow-y: auto; /* ✅ Allows scrolling */
}
        /* ✅ Scoreboard Styling */
/* ✅ Scoreboard Styling */
/* ✅ Scoreboard & Button Container */
/* ✅ Fixed Scoreboard & Buttons Alignment */
#scoreboardContainer {
    display: flex;
    flex-direction: column;
    align-items: center;
    position: absolute;
    top: 10px;
    left: 10px;
    width: 250px; /* ✅ Adjust width to avoid stretching */
    text-align: center;
}

/* ✅ Scoreboard Styling */
#scoreboard {
    background-color: #ffffff;
    border: 2px solid black;
    padding: 10px;
    width: 100%; 
    font-size: 14px;
    text-align: center;
}

/* ✅ Table Styling */
#scoreboard table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed;
}

#scoreboard th, #scoreboard td {
    border: 1px solid black;
    padding: 5px;
    text-align: center;
    word-break: break-word;
}

#scoreboard th {
    background-color: #f2f2f2;
}

/* ✅ Buttons Below Scoreboard */
#buttonContainer {
    display: flex;
    flex-direction: column;
    width: 100%;
    margin-top: 5px;
}

#returnToMainMenu, #forceReturnToWaitingRoom {
    width: 100%;
    padding: 8px 15px;
    border: none;
    cursor: pointer;
    font-weight: bold;
}

#returnToMainMenu {
    background-color: red;
    color: white;
}

#forceReturnToWaitingRoom {
    background-color: blue;
    color: white;
}

/* ✅ GAME RULES*/
#gameRulesButton {
    position: fixed;
    top: 10px;
    right: 10px;
    background-color: #008CBA;
    color: white;
    padding: 8px 15px;
    border: none;
    cursor: pointer;
    font-weight: bold;
    border-radius: 5px;
}

#gameRulesBox {
    position: fixed;
    top: 50px;
    right: 10px;
    width: 300px;
    padding: 15px;
    background-color: white;
    border: 2px solid black;
    box-shadow: 0 0 10px rgba(0,0,0,0.3);
    display: none; /* Hidden by default */
    text-align: left;
}

#gameRulesBox h3 {
    text-align: center;
    margin-bottom: 10px;
}

#gameRulesBox ul {
    padding-left: 20px;
}

.hidden {
    display: none;
}
#playerNameDisplay {
    position: fixed;
    top: 10px;
    right: 120px; /* Moves it to the left of Game Rules */
    font-weight: bold;
    font-size: 16px;
    color: black;
}

/* ✅ Center the Lobby Table */
#lobbyArea {
    display: none; /* Removed !important */
    text-align: center;
    margin: 20px auto;
    width: 60%;
}


/* ✅ Ensure the lobby becomes visible when needed */
#lobbyArea.show {
    display: block !important; /* 🚀 Force show when required */
}

/* ✅ Style the Table */
#gamesTable {
    width: 100%;
    border-collapse: collapse;
    margin-top: 15px; /* Increased for better spacing */
    box-shadow: 2px 2px 10px rgba(0, 0, 0, 0.1); /* Light shadow for better look */
}

/* ✅ Improve Table Cell Styling */
#gamesTable th, 
#gamesTable td {
    border: 1px solid #ccc;
    padding: 10px;
    text-align: center;
    font-size: 16px; /* Slightly larger text for readability */
}

/* ✅ Header Styling */
#gamesTable th {
    background-color: #f2f2f2;
    font-weight: bold;
}

/* ✅ Style the Search Box */
#gameSearch {
    width: 80%;
    padding: 8px;
    margin-bottom: 10px;
    border: 1px solid #ccc;
    border-radius: 5px;
    font-size: 14px;
    text-align: center;
}

/* ✅ Responsive for Smaller Screens */
@media (max-width: 768px) {
    #lobbyArea {
        width: 90%;
    }

    #gamesTable th, #gamesTable td {
        font-size: 14px;
        padding: 6px;
    }

    #gameSearch {
        width: 90%;
    }
}







    </style>

    <script>
        // ✅ Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB1PPLZl8380-xEpyVX3z8ya9eRji2H-uk",
            authDomain: "upper-2c864.firebaseapp.com",
            databaseURL: "https://upper-2c864-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "upper-2c864",
            storageBucket: "upper-2c864.firebasestorage.app",
            messagingSenderId: "1065732661608",
            appId: "1:1065732661608:web:2db40ab8d60697b34f6dd",
            measurementId: "G-F348XKS47Q"
        };

// ✅ Firebase Initialization
firebase.initializeApp(firebaseConfig);
const db = firebase.database();

// ✅ Function to Check Active Players
function countActivePlayers() {
    db.ref("games").once("value", snapshot => {
        let playerSet = new Set();
        snapshot.forEach(gameSnapshot => {
            const gameData = gameSnapshot.val();
            if (gameData.players) {
                Object.keys(gameData.players).forEach(playerName => {
                    playerSet.add(playerName);
                });
            }
        });

        console.log(`Total Active Players: ${playerSet.size}`);
        alert(`Total Active Players in Server: ${playerSet.size}`);
    });
}

function cleanUpAllInactiveGames() {
    console.log("🔄 Running cleanUpAllInactiveGames...");

    db.ref("games").once("value", snapshot => {
        const now = Date.now();
        let removedGames = 0;

        snapshot.forEach(gameSnapshot => {
            const gameCode = gameSnapshot.key;
            const gameData = gameSnapshot.val();

            // ✅ Conditions for Removal
            const hasNoPlayers = !gameData.players || Object.keys(gameData.players).length === 0;
            const lastUpdated = gameData.lastUpdated || 0;
            const isInactiveForLong = now - lastUpdated > 60 * 60 * 1000; // 1 hour inactivity

            if (hasNoPlayers || isInactiveForLong) {
                // ✅ Delete the game and its players
                db.ref(`games/${gameCode}`).remove().then(() => {
                    console.log(`✅ Removed inactive game: ${gameCode} and its players.`);
                });

                removedGames++;
            }
        });

        console.log(`🚀 Total inactive games removed: ${removedGames}`);
    });
}


function cleanUpInactivePlayers() {
    console.log("🔄 Running cleanUpInactivePlayers...");

    db.ref("activePlayers").once("value", snapshot => {
        const now = Date.now();

        snapshot.forEach(playerSnapshot => {
            const playerData = playerSnapshot.val();
            if (!playerData || now - playerData.timestamp > 5 * 60 * 1000) { // 5 minutes inactivity
                db.ref(`activePlayers/${playerSnapshot.key}`).remove().then(() => {
                    console.log(`✅ Removed inactive player: ${playerSnapshot.key}`);
                });
            }
        });
    });
}


setInterval(() => {
    cleanUpAllInactiveGames();
    cleanUpInactivePlayers();
}, 10 * 60 * 1000); // Runs every 10 minutes




        var gameCode = ""; 
        var playerName = "";

function confirmName() {
    playerName = document.getElementById("playerNameInput").value.trim();
    if (playerName === "") {
        alert("Please enter a valid name!");
        return;
    }

    db.ref("games").once("value", snapshot => {
        let nameTaken = false;

        snapshot.forEach(gameSnapshot => {
            const gameData = gameSnapshot.val();
            if (gameData.players && gameData.players[playerName]) {
                nameTaken = true;
            }
        });

        if (nameTaken) {
            alert("This name is already taken! Please enter a different name.");
        } else {
            // ✅ Show the lobby correctly
            document.getElementById("nameInput").classList.add("hidden");
            document.getElementById("setupArea").classList.remove("hidden"); 
            document.getElementById("lobbyArea").style.display = "block"; // ✅ Now it works!
            document.getElementById("lobbyArea").classList.remove("hidden"); 

            // ✅ Show player name
            const playerNameDisplay = document.getElementById("playerNameDisplay");
            playerNameDisplay.innerText = `👲 ${playerName}`;
            playerNameDisplay.classList.remove("hidden");

            // ✅ Load available games
            loadActiveGames();
        }
    });
}






// ✅ Function to Load Active Games into the Lobby
function loadActiveGames() {
    db.ref("games").on("value", snapshot => {
        const tableBody = document.getElementById("gamesTableBody");
        tableBody.innerHTML = ""; // Clear previous entries

        snapshot.forEach(gameSnapshot => {
            const gameCode = gameSnapshot.key;
            const gameData = gameSnapshot.val();

            if (gameData.status === "waiting" || gameData.status === "playing") {
                const playerCount = gameData.players ? Object.keys(gameData.players).length : 0;
                
                // ✅ Create a row for each game
                const row = `<tr>
                    <td>${gameCode}</td>
                    <td>${gameData.status}</td>
                    <td>${playerCount}</td>
                    <td><button onclick="joinGameFromLobby('${gameCode}')">Join</button></td>
                </tr>`;

                tableBody.innerHTML += row;
            }
        });
    });
}

// ✅ Run on Page Load to Show Available Games
window.onload = function () {
    loadActiveGames();
};


function joinGameFromLobby(gameCodeParam) {
    gameCode = gameCodeParam.toUpperCase(); // ✅ SET THE GLOBAL gameCode VARIABLE

    db.ref("games/" + gameCode).get().then(snapshot => {
        if (snapshot.exists()) {
            const gameData = snapshot.val();

            // ✅ Check if the game is currently playing
            if (gameData.status === "playing") {
                alert("Game is currently in progress. Please wait for the next round.");
                return;
            }

            // ✅ Hide Lobby and Show Game UI
            document.getElementById("setupArea").classList.add("hidden");
            document.getElementById("lobbyArea").classList.add("hidden");
            document.getElementById("lobbyArea").style.display = "none";
            document.getElementById("gameArea").classList.remove("hidden");

            // ✅ Add Player to Game in Firebase, then listen for updates
            db.ref("games/" + gameCode + "/players/" + playerName).set(true)
                .then(() => {
                    console.log(`✅ ${playerName} joined game ${gameCode}`);
                    listenForUpdates(); // ✅ Start listening for the correct game
                })
                .catch(error => console.error("Error joining game:", error));

        } else {
            alert("Game not found!");
        }
    });
}




        function filterGames() {
    const searchValue = document.getElementById("gameSearch").value.toUpperCase();
    const rows = document.querySelectorAll("#gamesTable tbody tr");

    rows.forEach(row => {
        const gameCode = row.cells[0].innerText.toUpperCase();
        row.style.display = gameCode.includes(searchValue) ? "" : "none";
    });
}

   

function createGame() {
    gameCode = Math.random().toString(36).substr(2, 6).toUpperCase();
    var totalRounds = document.getElementById("roundsSlider").value;
    var roundTime = document.getElementById("timeSlider").value;

    db.ref("games/" + gameCode).set({
        status: "waiting",
        players: {},
        host: playerName,
        chat: {},
        totalRounds: totalRounds,
        roundTime: roundTime
    }).then(() => {
        document.getElementById("gameCodeDisplay").innerText = gameCode;
        document.getElementById("setupArea").classList.add("hidden");
        document.getElementById("lobbyArea").classList.add("hidden"); // ✅ Hide lobby when creating a game
        document.getElementById("lobbyArea").style.display = "none";
        document.getElementById("gameArea").classList.remove("hidden");

        db.ref("games/" + gameCode + "/players/" + playerName).set(true);
        listenForUpdates();
    });
}



function joinGame() {
    gameCode = document.getElementById("gameCodeInput").value.toUpperCase();
    if (!gameCode) {
        alert("Please enter a valid game code!");
        return;
    }

    db.ref("games/" + gameCode).get().then(snapshot => {
        if (snapshot.exists()) {
            const gameData = snapshot.val();

            // ✅ Check if the game is currently playing
            if (gameData.status === "playing") {
                alert("Game is currently in progress. Please wait for the next round.");
                return;
            }

            // ✅ Hide lobby and show game area
            document.getElementById("setupArea").classList.add("hidden");
            document.getElementById("lobbyArea").classList.add("hidden"); // ✅ Hide lobby when joining manually
            document.getElementById("lobbyArea").style.display = "none";
            document.getElementById("gameArea").classList.remove("hidden");

            // ✅ Add player to Firebase and listen for updates
            db.ref("games/" + gameCode + "/players/" + playerName).set(true);
            listenForUpdates();
        } else {
            alert("Game not found!");
        }
    });
}



    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////LISTENFORUPDATE////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
let lastKnownRound = 0;
let definitionShownThisRound = false;
let selectedTermsFile = "9upper_terms.json"; // ✅ Default to English terms

function listenForUpdates() {
    db.ref("games/" + gameCode).on("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        // ✅ Ensure `selectedTermsFile` updates correctly
        selectedTermsFile = gameData.termsFile || "9upper_terms.json";

        console.log("✅ Using terms file:", selectedTermsFile);

        // ✅ Move players to the waiting room if needed
        if (gameData.status === "waiting") {
            document.getElementById("gameScreen").classList.add("hidden");
            document.getElementById("waitingRoom").classList.remove("hidden");
            document.getElementById("lobbyArea").style.display = "none";
        }

        // ✅ Update Player List
        if (gameData.players) {
            var playerList = Object.keys(gameData.players)
                .map(name => `<li>${name}</li>`).join("");
            document.getElementById("playerList").innerHTML = `<ul>${playerList}</ul>`;
        }

        // ✅ If host, show game settings
        if (gameData.host === playerName) {
            document.getElementById("gameSettings").classList.remove("hidden");
            document.getElementById("startGameButton").classList.remove("hidden");

            document.getElementById("timeSlider").value = gameData.roundTime || 60;
            document.getElementById("timeValue").innerText = gameData.roundTime || 60;
            document.getElementById("roundsSlider").value = gameData.totalRounds || 5;
            document.getElementById("roundsValue").innerText = gameData.totalRounds || 5;
            document.getElementById("languageToggle").value = 
                selectedTermsFile === "chinese_terms.json" ? "chinese" : "english";

            // ✅ Event Listeners to update Firebase settings
            document.getElementById("timeSlider").oninput = function () {
                db.ref("games/" + gameCode).update({ roundTime: this.value });
            };
            document.getElementById("roundsSlider").oninput = function () {
                db.ref("games/" + gameCode).update({ totalRounds: this.value });
            };
            document.getElementById("languageToggle").onchange = function () {
                let newTermsFile = this.value === "chinese" ? "chinese_terms.json" : "9upper_terms.json";
                db.ref("games/" + gameCode).update({ termsFile: newTermsFile });
            };
        } else {
            document.getElementById("gameSettings").classList.add("hidden");
            document.getElementById("startGameButton").classList.add("hidden");
        }

        // ✅ Show "Return to Waiting Room" button if host
        document.getElementById("forceReturnToWaitingRoom").classList.toggle(
            "hidden",
            !(gameData.host === playerName && gameData.status === "playing")
        );

        // ✅ Auto-Update Scoreboard
        if (gameData.scores) {
            updateScoreboard(gameData.scores);
        }

        // ✅ Chatbox Auto-Scrolling
        if (gameData.chat) {
            const chatBox = document.querySelector(".chatbox");
            const isAtBottom = chatBox.scrollHeight - chatBox.clientHeight <= chatBox.scrollTop + 1;
            const previousScrollHeight = chatBox.scrollHeight;

            // ✅ Update chat content
            chatBox.innerHTML = Object.values(gameData.chat)
                .map(msg => `<p>${msg}</p>`).join("");

            // ✅ Auto-scroll logic:
            if (isAtBottom || chatBox.scrollHeight > previousScrollHeight) {
                setTimeout(() => chatBox.scrollTop = chatBox.scrollHeight, 100);
            }
        }

        // ✅ Auto-scroll when player sends message
        const chatInput = document.querySelector(".chatbox input");
        if (chatInput) {
            chatInput.addEventListener("keypress", function (event) {
                if (event.key === "Enter") {
                    setTimeout(() => {
                        document.querySelector(".chatbox").scrollTop = document.querySelector(".chatbox").scrollHeight;
                    }, 100);
                }
            });
        }

        // ✅ Game State: Playing
        if (gameData.status === "playing") {
            document.getElementById("waitingRoom").classList.add("hidden");
            document.getElementById("gameScreen").classList.remove("hidden");

            document.getElementById("gameTerm").innerText = gameData.term;
            document.getElementById("playerRole").innerText = gameData.roles[playerName];
            document.getElementById("currentRoundDisplay").innerText = gameData.currentRound;
            document.getElementById("totalRoundsDisplay").innerText = gameData.totalRounds;

            // ✅ Detect new round
            if (gameData.currentRound !== lastKnownRound) {
                lastKnownRound = gameData.currentRound;
                definitionShownThisRound = false;

                if (gameData.host === playerName) {
                    startCountdown(
                        gameData.timeLeft,
                        gameData.currentRound,
                        gameData.totalRounds,
                        gameData.roundTime
                    );
                }
            }

            document.getElementById("timeLeftDisplay").innerText = gameData.timeLeft + " seconds";
            document.getElementById("thinkerPanel").classList.add("hidden");

            // ✅ Display thinker options
            displaythinkerOptions(gameData);
        }

        // ✅ Always show "Return to Main Menu"
        document.getElementById("returnToMainMenu").classList.remove("hidden");

        // ✅ Handle Game End
        if (gameData.status === "finished") {
            db.ref("games/" + gameCode).update({ status: "post-finished" });
            showEndgameScreen(gameData.scores);
        }
    });
}









////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////LISTENFORUPDATE////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        





        





var roundTimer; // ✅ Global timer variable

function startCountdown(timeLeft, round, totalRounds, roundTime) {
    // ✅ Ensure valid timeLeft
    if (isNaN(timeLeft) || timeLeft === undefined) {
        console.error("Error: timeLeft is NaN or undefined, resetting to 60");
        timeLeft = 60;
    }

    clearInterval(roundTimer);

    // ✅ Start a new interval timer
    roundTimer = setInterval(() => {
        if (timeLeft <= 0) {
            clearInterval(roundTimer);

            // ✅ Set timeLeft = 0 in Firebase
            db.ref(`games/${gameCode}`).update({ timeLeft: 0 }).then(() => {
                db.ref(`games/${gameCode}`).once("value", snapshot => {
                    const gameData = snapshot.val();
                    if (!gameData) return;

                    const winner = gameData.winner || null;
                    const roles = gameData.roles || {};
                    const collectSkins = Array.isArray(gameData.collectSkins) ? gameData.collectSkins : [];
                    const scores = gameData.scores || {};

                    const thinker = Object.keys(roles).find(p => roles[p] === "thinker");
                    const realUpper = Object.keys(roles).find(p => roles[p] === "REALUPPER");

                    console.log("DEBUG Partial Scoring:", { winner, thinker, realUpper, collectSkins });

                    // ✅ Apply partial scoring if no winner
                    if (!winner && thinker && realUpper && collectSkins.length > 0) {
                        const collectSkinMessages = [];

                        collectSkins.forEach(target => {
                            if (target === realUpper) {
                                // Thinker incorrectly collected from REALUPPER
                                scores[thinker] = (scores[thinker] || 0) - 1;
                                collectSkinMessages.push(`Thinker tried to collect from REALUPPER (${target}) ⇒ Thinker -1`);
                            } else {
                                // Thinker correctly collected from a 9UPPER
                                scores[thinker] = (scores[thinker] || 0) + 1;
                                scores[target] = (scores[target] || 0) - 1;
                                collectSkinMessages.push(`Thinker collected skin from 9UPPER (${target}) ⇒ Thinker +1, ${target} -1`);
                            }
                        });

                        // ✅ Push Collect Skin results to chat
                        collectSkinMessages.forEach(msg => {
                            db.ref(`games/${gameCode}/chat`).push(msg);
                        });

                        // ✅ Final "Time's up!" message
                        db.ref(`games/${gameCode}/chat`).push(`Time's up! Thinker did not pick anyone. REALUPPER was "${realUpper}".`);

                        // ✅ Update Firebase
                        db.ref(`games/${gameCode}`).update({ scores: scores, collectSkins: [] }).then(() => {
                            updateScoreboard(scores);
                        });
                    } else if (!winner && thinker && realUpper) {
                        db.ref(`games/${gameCode}/chat`).push(`Time's up! No pick made. REALUPPER was "${realUpper}".`);
                    }

                    // ✅ Move to the next round or end the game
                    if (round >= totalRounds) {
                        endRound(round, totalRounds);
                    } else {
                        const nextRound = (gameData.currentRound || 0) + 1;

                        // ✅ Fetch terms file dynamically
                        fetch(selectedTermsFile)
                            .then(response => response.json())
                            .then(terms => {
                                startNewRound(terms, nextRound, totalRounds, roundTime);
                            })
                            .catch(error => console.error("Error fetching terms file:", error));
                    }
                });
            });

        } else {
            // ✅ Decrement time and update Firebase
            timeLeft--;
            db.ref(`games/${gameCode}`).update({ timeLeft });

            // ✅ Update UI countdown
            document.getElementById("timeLeftDisplay").innerText = `${timeLeft} seconds`;
        }
    }, 1000);
}








        

function displaythinkerOptions(gameData) {
    var thinker = Object.keys(gameData.players).find(p => gameData.roles[p] === "thinker");
    var playerRole = gameData.roles[playerName];

    // Track the number of times Collect Skin has been used
    var collectSkins = gameData.collectSkins || [];
    var collectSkinCount = collectSkins.length; // Number of times thinker has collected

    if (playerRole === "thinker") {
        document.getElementById("thinkerPanel").classList.remove("hidden");

        var selectablePlayers = Object.keys(gameData.players).filter(p => p !== thinker);

        // Row 1: "Pick: [player1] [player2] ..."
        const pickButtons = selectablePlayers.map(player => {
            return `<button onclick="thinkerSelectPlayer('${player}')">
                        ${player}
                    </button>`;
        }).join(" ");

        // Row 2: "Collect Skin: [player1] [player2] ..." (Disable after 2 uses)
        const collectSkinButtons = selectablePlayers.map(player => {
            return `<button onclick="thinkerCollectSkin('${player}')"
                        ${collectSkinCount >= 2 ? "disabled" : ""}>
                        ${player}
                    </button>`;
        }).join(" ");

        // Add them to thinkerOptions in two distinct lines/rows
        document.getElementById("thinkerOptions").innerHTML = `
            <div style="margin-bottom: 8px;">
                <strong>Pick:</strong> ${pickButtons}
            </div>
            <div>
                <strong>Collect Skin:</strong> ${collectSkinButtons}
                <span style="font-size: 12px; color: gray;">
                    (${2 - collectSkinCount} remaining)
                </span>
            </div>
        `;
    } else {
        // Hide panel if not thinker
        document.getElementById("thinkerPanel").classList.add("hidden");
        document.getElementById("thinkerOptions").innerHTML = "";
    }
}











function thinkerSelectPlayer(selectedPlayer) {
    clearInterval(roundTimer);

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        // ✅ Ensure we fetch the correct terms file from Firebase
        selectedTermsFile = gameData.termsFile || "9upper_terms.json";

        var scores = gameData.scores || {};
        var roles = gameData.roles || {};
        var thinker = Object.keys(roles).find(p => roles[p] === "thinker");
        var realUpper = Object.keys(roles).find(p => roles[p] === "REALUPPER");
        var collectSkins = gameData.collectSkins || [];
        var correctDefinition = gameData.correctDefinition || "Definition unavailable"; // ✅ Ensure definition exists

        // 1) Apply any collected-skin logic
        collectSkins.forEach(target => {
            if (target === realUpper) {
                // If the thinker tried to collect from the REALUPPER
                scores[thinker] = (scores[thinker] || 0) - 1;
            } else {
                // Otherwise, target is presumably a 9UPPER
                scores[thinker] = (scores[thinker] || 0) + 1;
                scores[target]   = (scores[target]   || 0) - 1;
            }
        });

        // 2) Apply the final pick logic
        let message = "";
        if (selectedPlayer === realUpper) {
            scores[thinker]   = (scores[thinker]   || 0) + 1;
            scores[realUpper] = (scores[realUpper] || 0) + 1;
            message = `Thinker picked ${realUpper}, which is correct! (Thinker & REALUPPER both +1)`;
        } else {
            scores[selectedPlayer] = (scores[selectedPlayer] || 0) + 1;
            message = `Thinker guessed wrong! REALUPPER was "${realUpper}".`;
        }

        // ✅ Always announce the correct definition
        let definitionMessage = `The correct definition for this round was: "${correctDefinition}"`;

        // 3) Push both messages to chat so everyone sees them
        db.ref("games/" + gameCode + "/chat").push(message);
        db.ref("games/" + gameCode + "/chat").push(definitionMessage); // ✅ New definition message

        // 4) Update DB: new scores, set winner, clear collectSkins, end the round
        db.ref("games/" + gameCode).update({
            scores: scores,
            winner: selectedPlayer,
            timeLeft: 0,
            collectSkins: [] // Clear for next round
        }).then(() => {
            updateScoreboard(scores);
        });

        // 5) Either move to next round or end game
        db.ref("games/" + gameCode + "/currentRound").once("value", roundSnapshot => {
            var round = roundSnapshot.val();
            db.ref("games/" + gameCode + "/totalRounds").once("value", totalSnapshot => {
                var totalRounds = totalSnapshot.val();

                if (round >= totalRounds) {
                    endRound(round, totalRounds);
                } else {
                    fetch(selectedTermsFile)  // ✅ Using `selectedTermsFile` here
                        .then(response => response.json())
                        .then(terms => {
                            startNewRound(terms, round + 1, totalRounds, gameData.roundTime);
                        })
                        .catch(error => console.error("❌ Error loading terms file:", error));
                }
            });
        });
    });
}











function startGame() {
    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        var totalRounds = gameData.totalRounds;
        var roundTime = gameData.roundTime;
        selectedTermsFile = gameData.termsFile || "9upper_terms.json"; // ✅ Default to English if not set

        console.log(`🚀 Fetching terms from: ${selectedTermsFile}`);

        fetch(selectedTermsFile)
            .then(response => response.json())
            .then(terms => {
                db.ref("games/" + gameCode + "/players").once("value", playerSnapshot => {
                    var players = Object.keys(playerSnapshot.val() || {}); // ✅ Ensure players exist
                    if (players.length < 3) {
                        alert("At least 3 players are needed to start the game!");
                        return;
                    }

                    var thinker = players[Math.floor(Math.random() * players.length)];
                    var correctPlayer = players.filter(p => p !== thinker)[Math.floor(Math.random() * (players.length - 1))];

                    var roles = {};
                    players.forEach(p => roles[p] = "9UPPER");
                    roles[thinker] = "thinker";
                    roles[correctPlayer] = "REALUPPER";

                    var randomIndex = Math.floor(Math.random() * terms.length);
                    var randomTerm = terms[randomIndex].term;
                    var correctDefinition = terms[randomIndex].definition;

                    // ✅ Initialize scores for all players
                    var initialScores = {};
                    players.forEach(p => initialScores[p] = 0);

                    // ✅ Update Firebase with game settings
                    db.ref("games/" + gameCode).update({
                        status: "playing",
                        term: randomTerm,
                        correctDefinition: correctDefinition,
                        roles: roles,
                        currentRound: 1,
                        totalRounds: totalRounds,
                        roundTime: roundTime,
                        scores: initialScores,
                        termsFile: selectedTermsFile // ✅ Save selected language file in Firebase
                    }).then(() => {
                        console.log("✅ Game started successfully");
                        startNewRound(terms, 1, totalRounds, roundTime);
                    }).catch(error => console.error("❌ Error starting game:", error));
                });
            })
            .catch(error => {
                console.error("❌ Error loading terms file:", error);
                alert("Error loading terms file. Please try again.");
            });
    });
}


        var roundTimer;

function startNewRound(terms, round, totalRounds, roundTime) {
    // ✅ Ensure roundTime is always valid
    if (isNaN(roundTime) || roundTime === undefined) {
        console.error("Error: roundTime is NaN or undefined, resetting to 60");
        roundTime = 60;  // ✅ Default to 60 seconds if undefined
    }

    // ✅ Ensure round is a valid number
    if (isNaN(round) || round === undefined) {
        console.error("Error: round is NaN or undefined, resetting to 1");
        round = 1;
    }

    db.ref("games/" + gameCode + "/players").once("value", snapshot => {
        var players = Object.keys(snapshot.val() || {});
        if (players.length < 3) return;

        var thinker = players[Math.floor(Math.random() * players.length)];
        var correctPlayer = players.filter(p => p !== thinker)[Math.floor(Math.random() * (players.length - 1))];

        var roles = {};
        players.forEach(p => roles[p] = "9UPPER");
        roles[thinker] = "thinker";
        roles[correctPlayer] = "REALUPPER";

        var randomIndex = Math.floor(Math.random() * terms.length);
        var randomTerm = terms[randomIndex].term;
        var correctDefinition = terms[randomIndex].definition;

        db.ref("games/" + gameCode).update({
            currentRound: round,
            term: randomTerm,
            correctDefinition: "",  // ✅ Reset before assigning a new value
            roles: roles,
            timeLeft: roundTime,  // ✅ Ensure it's always a number
            winner: null, // ✅ Reset winner for new round
            collectSkins: [] // ✅ Always reset collectSkins at the start of a round
        }).then(() => {
            db.ref("games/" + gameCode).update({
                correctDefinition: correctDefinition // ✅ Now set the correct definition for the new REALUPPER
            });
             // ✅ Send a chat message announcing the thinker
            db.ref("games/" + gameCode + "/chat").push(
                `Round ${round}, player ${thinker} is the thinker.`
            );
        });

        var roundDisplay = document.getElementById("currentRoundDisplay");
        if (roundDisplay) {
            roundDisplay.innerText = round;
        }

        startRoundTimer(roundTime, round, totalRounds);
    });
}






function startRoundTimer(roundTime, round, totalRounds) {
    clearInterval(roundTimer); // ✅ Stop any existing timer

    db.ref("games/" + gameCode).update({ timeLeft: roundTime }); // ✅ Ensure Firebase starts at the right time

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        if (playerName === gameData.host) {  // ✅ Only the host updates Firebase
            roundTimer = setInterval(() => {
                db.ref("games/" + gameCode).once("value", snapshot => {
                    var gameData = snapshot.val();
                    if (!gameData) return;

                    var timeLeft = gameData.timeLeft || 0;

                    if (timeLeft <= 0) {  
                        // clearInterval(roundTimer);
                        // if (!gameData.winner) {  
                        //     db.ref("games/" + gameCode).update({ winner: "timeout" }); // ✅ Mark timeout
                        // }
                        endRound(round, totalRounds); // ✅ Start next round
                    } else {
                        db.ref("games/" + gameCode).update({ timeLeft: timeLeft - 1 });
                    }
                });
            }, 1000);
        }
    });
}






function endRound(round, totalRounds) {
    clearInterval(roundTimer); // Stop any running timer

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        // ✅ Ensure we fetch the correct terms file from Firebase
        selectedTermsFile = gameData.termsFile || "9upper_terms.json";

        // 1) Copy the old round data before resetting it
        var oldRoles = { ...gameData.roles };
        var oldCollectSkins = Array.isArray(gameData.collectSkins) ? [...gameData.collectSkins] : [];
        var oldScores = { ...gameData.scores };
        var winner = gameData.winner || null; 
        var roundTime = gameData.roundTime;

        // ✅ Store the correct definition BEFORE resetting
        var correctDefinition = gameData.correctDefinition || "Definition unavailable";
        var definitionMessage = `The correct definition for this round was: "${correctDefinition}".`;

        // Identify roles from the old data
        var thinker = Object.keys(oldRoles).find(p => oldRoles[p] === "thinker");
        var realUpper = Object.keys(oldRoles).find(p => oldRoles[p] === "REALUPPER");

        // ✅ Always announce the correct definition message FIRST
        db.ref(`games/${gameCode}/chat`).push(definitionMessage);

        // 2) Handle time expiration logic if the thinker never picked
        if (!winner && thinker && realUpper && oldCollectSkins.length > 0) {
            let collectSkinMessages = [];

            oldCollectSkins.forEach(target => {
                if (target === realUpper) {
                    // Thinker tried to collect from REALUPPER
                    oldScores[thinker] = (oldScores[thinker] || 0) - 1;
                    collectSkinMessages.push(`Thinker tried to collect from REALUPPER (${target}) ⇒ Thinker -1`);
                } else {
                    // Thinker collected from a 9UPPER
                    oldScores[thinker] = (oldScores[thinker] || 0) + 1;
                    oldScores[target] = (oldScores[target] || 0) - 1;
                    collectSkinMessages.push(`Thinker collected skin from 9UPPER (${target}) ⇒ Thinker +1, ${target} -1`);
                }
            });

            // Push breakdown messages to chat
            collectSkinMessages.forEach(msg => {
                db.ref(`games/${gameCode}/chat`).push(msg);
            });

            // ✅ Announce REALUPPER at the end
            db.ref(`games/${gameCode}/chat`).push(`Time's up! Thinker did not pick anyone. REALUPPER was "${realUpper}".`);

            // Apply updated scores & clear collectSkins
            db.ref(`games/${gameCode}`).update({
                scores: oldScores,
                collectSkins: []
            });
        } 
        else if (!winner && thinker && realUpper) {
            // If there's no winner but also no collectSkins, just reveal the REALUPPER
            db.ref(`games/${gameCode}/chat`).push(`Time's up! No pick made. REALUPPER was "${realUpper}".`);
        } 

        // 3) Move to next round or finish
        if (round >= totalRounds) {
            // Mark the game as finished
            db.ref(`games/${gameCode}`).update({ status: "finished" });
        } else {
            fetch(selectedTermsFile)  // ✅ Using `selectedTermsFile` here
                .then(response => response.json())
                .then(terms => {
                    // ✅ Only reset round settings **after** messages are sent
                    db.ref(`games/${gameCode}`).update({
                        term: "",
                        correctDefinition: "",
                        roles: {},
                        winner: null,
                        timeLeft: roundTime
                    }).then(() => {
                        startNewRound(terms, round + 1, totalRounds, roundTime);
                    });
                })
                .catch(error => console.error("❌ Error loading terms file:", error));
        }
    });
}













function sendChatMessage() {
    var message = $("#chatInput").val().trim(); // ✅ Use jQuery for input field
    if (message === "") return;

    db.ref("games/" + gameCode + "/chat").push(playerName + ": " + message).then(() => {
        var chatBox = $("#chatMessages"); // ✅ Use jQuery for chatbox

        // ✅ Smooth auto-scroll using jQuery
        chatBox.animate({
            scrollTop: chatBox.prop("scrollHeight")  // ✅ Correct usage
        }, 1000);
    });

    $("#chatInput").val(""); // ✅ Clear input field using jQuery
}




function updateRounds() {
    document.getElementById("roundsValue").innerText = document.getElementById("roundsSlider").value;
}

function updateTime() {
    document.getElementById("timeValue").innerText = document.getElementById("timeSlider").value;
}

   function updateScoreboard(scores) {
    var scoreboardBody = document.getElementById("scoreboardBody");
    scoreboardBody.innerHTML = ""; // Clear current scoreboard

    // Convert scores object into an array and sort by score (descending)
    var sortedPlayers = Object.entries(scores).sort((a, b) => b[1] - a[1]);

    sortedPlayers.forEach((player, index) => {
        var row = `<tr>
            <td>${index + 1}</td>
            <td style="max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${player[0]}</td>
            <td>${player[1]}</td>
        </tr>`;
        scoreboardBody.innerHTML += row;
    });
}


  // ✅ Global timer variable
var roundTimer;


        function handleGameEnd() {
    db.ref("games/" + gameCode).update({ status: "finished" });
}


function showEndgameScreen(scores) {
    // ✅ If the endGameModal already exists, do nothing
    if (document.getElementById("endGameModal")) {
        console.log("Endgame screen already shown. Not firing again.");
        return;
    }
  // ✅ Hide Game Settings & Start Game button for everyone
    const gameSettingsDiv = document.getElementById("gameSettings");
    const startGameBtn = document.getElementById("startGameButton");
    if (gameSettingsDiv) {
        gameSettingsDiv.classList.add("hidden");
    }
    if (startGameBtn) {
        startGameBtn.classList.add("hidden");
    }
    
    var endGameModal = document.createElement("div");
    endGameModal.id = "endGameModal";
    endGameModal.style.position = "fixed";
    endGameModal.style.top = "50%";
    endGameModal.style.left = "50%";
    endGameModal.style.transform = "translate(-50%, -50%)";
    endGameModal.style.background = "white";
    endGameModal.style.padding = "20px";
    endGameModal.style.borderRadius = "10px";
    endGameModal.style.boxShadow = "0 0 10px rgba(0,0,0,0.3)";
    endGameModal.style.textAlign = "center";

    var sortedScores = Object.entries(scores).sort((a, b) => b[1] - a[1]);

    var scoreHTML = `<h2>Game Over!</h2><h3>Final Scores</h3>
        <table border="1" style="margin:auto;">
        <tr><th>Rank</th><th>Player</th><th>Score</th></tr>`;

    sortedScores.forEach((player, index) => {
        scoreHTML += `<tr><td>${index + 1}</td><td>${player[0]}</td><td>${player[1]}</td></tr>`;
    });

    scoreHTML += `</table><br>`;

    endGameModal.innerHTML = scoreHTML + `
        <button onclick="returnToWaitingRoom()" style="background:blue;color:white;padding:10px;border:none;margin:5px;">Back to Waiting Room</button>
        <button onclick="returnToMainMenu()" style="background:red;color:white;padding:10px;border:none;margin:5px;">Back to Main Menu</button>
    `;

    document.body.appendChild(endGameModal);


    // Remove players from the waiting room when the game ends
    db.ref("games/" + gameCode + "/players").once("value", snapshot => {
        var players = snapshot.val();
        if (players) {
            Object.keys(players).forEach(player => {
                db.ref("games/" + gameCode + "/players/" + player).remove();
            });
        }
    });
}








function returnToWaitingRoom() {
    // ✅ Check if the modal exists before removing
    document.getElementById("endGameModal").remove();

    // ✅ Hide Game Screen & Show Waiting Room
    document.getElementById("gameScreen").classList.add("hidden");
    document.getElementById("waitingRoom").classList.remove("hidden");

    // ✅ Update Firebase: Set game status to "waiting"
    db.ref("games/" + gameCode).update({ status: "waiting" });

    // ✅ Re-add the player to the waiting room
    db.ref("games/" + gameCode + "/players/" + playerName).set(true);
}






function returnToMainMenu() {
    const endGameModal = document.getElementById("endGameModal");
    if (endGameModal) {
        endGameModal.remove();
    }

    db.ref("games/" + gameCode).once("value", (gameSnapshot) => {
        const gameData = gameSnapshot.val();
        if (!gameData) return;

        // ✅ If the leaving player is the host and game is playing, reset game state
        if (gameData.host === playerName && gameData.status === "playing") {
            console.log("Host is leaving mid-game. Moving everyone to waiting room...");
            forceReturnToWaitingRoom(); // ✅ Move all players back to waiting room
        }

        // ✅ Remove player from game
        db.ref("games/" + gameCode + "/players/" + playerName).remove();

        // ✅ Move player back to the lobby instead of reloading
        setTimeout(() => {
            document.getElementById("gameArea").classList.add("hidden");  // Hide Game UI
            document.getElementById("waitingRoom").classList.add("hidden");  // Hide Waiting Room
            document.getElementById("setupArea").classList.remove("hidden");  // Show Create/Join Game
            document.getElementById("lobbyArea").style.display = "block";  // Show Lobby

            // ✅ Clear gameCode since they left the game
            gameCode = "";

            // ✅ Re-load the available games list
            loadActiveGames();
        }, 500);
    });
}



function forceReturnToWaitingRoom() {
  console.log("Forcing all players back to the waiting room...");

  // Update game status to waiting
  db.ref("games/" + gameCode).update({ status: "waiting" });


  // Host immediately hides the game UI
  document.getElementById("gameScreen").classList.add("hidden");
  document.getElementById("waitingRoom").classList.remove("hidden");

  // Hide the button
  document.getElementById("forceReturnToWaitingRoom").classList.add("hidden");
}


function thinkerCollectSkin(selectedPlayer) {
    // 1) Push a message to chat so everyone sees what's happening
    db.ref("games/" + gameCode + "/chat").push(
        `Thinker is collecting skin from "${selectedPlayer}" ...`
    );

    // 2) Record the selectedPlayer in collectSkins, so we apply points at round end or final pick
    db.ref("games/" + gameCode + "/collectSkins").once("value", snapshot => {
        let collectSkins = snapshot.val() || [];
        if (!Array.isArray(collectSkins)) collectSkins = [];
        collectSkins.push(selectedPlayer);

        db.ref("games/" + gameCode).update({
            collectSkins: collectSkins
        });
    });
}



function checkAndReassignHost(gameData) {
    if (!gameData.players) return;
    const allPlayers = Object.keys(gameData.players);
    if (allPlayers.length === 0) return;

    // ✅ If the current host is still valid, do nothing
    if (allPlayers.includes(gameData.host)) {
        return;
    }

    // ✅ Find the next available host
    allPlayers.sort();
    const newHost = allPlayers[0]; // First alphabetical player becomes new host

    // ✅ Only the newHost's own client writes to the DB
    if (playerName === newHost) {
        const oldHost = gameData.host || "unknown";
        db.ref(`games/${gameCode}`).update({ host: newHost }).then(() => {
            console.log(`✅ Host successfully reassigned to: ${newHost}`);
            
            // ✅ Ensure UI updates immediately for the new host
            listenForUpdates();
        });

        // ✅ Inform players in chat
        db.ref(`games/${gameCode}/chat`).push(
            `The old host was missing, so "${newHost}" is now the new host. (Old was "${oldHost}")`
        );
    }
}


function toggleGameRules() {
    var rulesBox = document.getElementById("gameRulesBox");
    if (rulesBox.style.display === "none" || rulesBox.style.display === "") {
        rulesBox.style.display = "block";
    } else {
        rulesBox.style.display = "none";
    }
}

function updateLanguageSelection() {
    let selectedLanguage = document.getElementById("languageToggle").value;
    selectedTermsFile = selectedLanguage === "chinese" ? "chinese_terms.json" : "9upper_terms.json";

    // ✅ Save the selected language to Firebase so all players get the same terms file
    db.ref("games/" + gameCode).update({ termsFile: selectedTermsFile });

    console.log("✅ Language set to:", selectedTermsFile);
}



    </script>
</head>
<body>
    <h1>9upper Online Multiplayer</h1>

    <!-- ✅ Name Input Section -->
    <div id="nameInput">
        <input type="text" id="playerNameInput" placeholder="Enter Your Name">
        <button onclick="confirmName()">Continue</button>
    </div>

<!-- ✅ Player Name Display (Added Here) -->
<span id="playerNameDisplay" class="hidden"></span>

<!-- ✅ Game Rules Button -->
<button id="gameRulesButton" onclick="toggleGameRules()">Game Rules</button>

<!-- ✅ Game Rules Box (Hidden by Default) -->
<div id="gameRulesBox" class="hidden">
    <h3>9upper Game Rules</h3>
    <p><strong>Objective:</strong> Identify the REALUPPER among the players.</p>
    
    <p><strong>Roles:</strong></p>
    <ul>
        <li><strong>REALUPPER:</strong> The player with the correct definition.</li>
        <li><strong>9UPPER:</strong> Players with fake definitions trying to fool the thinker.</li>
        <li><strong>Thinker:</strong> The player trying to guess the REALUPPER.</li>
    </ul>

    <p><strong>Gameplay:</strong></p>
    <ul>
        <li>A word is displayed.</li>
        <li>REALUPPER sees the correct definition.</li>
        <li>9UPPERS make up fake definitions.</li>
        <li>The thinker selects who they think is the REALUPPER.</li>
        <li>Points are awarded based on selections.</li>
    </ul>

    <hr>

    <h3>Scoring System</h3>
    <ul>
        <li><strong>Thinker Pick:</strong>
            <ul>
                <li>If Thinker picks REALUPPER → <strong>Thinker +1, REALUPPER +1</strong></li>
                <li>If Thinker picks 9UPPER → No points awarded</li>
            </ul>
        </li>
        <li><strong>Thinker Collect Skin:</strong> (Hong Kong phrase for "shut the fxxk up")</li>
        <ul>
            <li>If Thinker collects skin from a 9UPPER → <strong>Thinker +1, 9UPPER -1</strong></li>
            <li>If Thinker collects skin from the REALUPPER → <strong>Thinker -1</strong></li>
        </ul>
    </ul>

    <p>Scores are calculated at the end of each round.</p>
</div>



    
    <!-- ✅ Setup Section -->
    <div id="setupArea" class="hidden">
        <button onclick="createGame()">Create Game</button>
        <input type="text" id="gameCodeInput" placeholder="Enter Game Code">
        <button onclick="joinGame()">Join Game</button>
    </div>

    <!-- ✅ Lobby Section -->
<div id="lobbyArea">
    <h2>Available Games</h2>
    <input type="text" id="gameSearch" placeholder="Search Game Code..." oninput="filterGames()">
    
    <table border="1" id="gamesTable">
        <thead>
            <tr>
                <th>Game Code</th>
                <th>Status</th>
                <th>Players</th>
                <th>Action</th>
            </tr>
        </thead>
        <tbody id="gamesTableBody">
            <!-- Games will be dynamically added here -->
        </tbody>
    </table>
</div>


    <!-- ✅ Main Game Area -->
    <div id="gameArea" class="hidden">
        <h2>Game Code: <span id="gameCodeDisplay"></span></h2>

        <!-- ✅ Waiting Room -->
        <div id="waitingRoom">
            <h2>Players in Room</h2>
            <div id="playerList"></div>

            <!-- ✅ Game Settings (Visible for Host Only) -->
            <div id="gameSettings" class="hidden">
                <h3>Game Settings</h3>
<!-- ✅ Language Selection Dropdown -->
<label for="languageToggle"><strong>Term Language:</strong></label>
<select id="languageToggle" onchange="updateLanguageSelection()">
    <option value="english">English</option>
    <option value="chinese">Chinese</option>
</select>
                <label for="roundsSlider">Rounds: <span id="roundsValue">5</span></label>
                <input type="range" id="roundsSlider" min="5" max="20" step="5" value="5" oninput="updateRounds()">
                <br>
                <label for="timeSlider">Time per Round (seconds): <span id="timeValue">60</span></label>
                <input type="range" id="timeSlider" min="10" max="600" step="10" value="60" oninput="updateTime()">
            </div>

            <!-- ✅ Start Game Button (Visible for Host Only) -->
            <button id="startGameButton" class="hidden" onclick="startGame()">Start Game</button>
        </div>

        <!-- ✅ Game Screen -->
        <div id="gameScreen" class="hidden">
            <h3>Round <span id="currentRoundDisplay"></span> / <span id="totalRoundsDisplay"></span></h3>
            <h3>Time Remaining: <span id="timeLeftDisplay">--</span></h3>
            <h3>Term: <span id="gameTerm"></span></h3>
            <h3>Your Role: <span id="playerRole"></span></h3>

            <!-- ✅ REALUPPER Definition Box -->
            <div id="correctDefinitionBox" class="hidden">
                <h3>REALUPPER: <span id="correctDefinition"></span></h3>
            </div>

            <!-- ✅ Thinker Panel -->
            <div id="thinkerPanel" class="hidden">
                <h3>Thinker: Pick the correct player</h3>
                <div id="thinkerOptions"></div>
            </div>
        </div>

        <!-- ✅ Chatbox -->
        <div class="chatbox">
            <div id="chatMessages"></div>
        </div>
        <input type="text" id="chatInput" placeholder="Type a message">
        <button onclick="sendChatMessage()">Send</button>

        <!-- ✅ Scoreboard and Buttons Container -->
        <div id="scoreboardContainer">
            <!-- ✅ Scoreboard Display -->
            <div id="scoreboard">
                <h3>Scoreboard</h3>
                <table>
                    <thead>
                        <tr>
                            <th>Rank</th>
                            <th>Player</th>
                            <th>Score</th>
                        </tr>
                    </thead>
                    <tbody id="scoreboardBody">
                        <!-- Scores will be dynamically inserted here -->
                    </tbody>
                </table>
            </div>

            <!-- ✅ Button Container (Aligned with Scoreboard) -->
            <div id="buttonContainer">
                <button id="returnToMainMenu" onclick="returnToMainMenu()">Return to Main Menu</button>
                <button id="forceReturnToWaitingRoom" class="hidden" onclick="forceReturnToWaitingRoom()">Return to Waiting Room</button>
            </div>
        </div>
    </div>
</body>

</html>
