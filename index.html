<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>9upper Online</title>

    <!-- ✅ Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .hidden {
            display: none;
        }
        .chatbox {
    width: 300px;
    height: 200px;
    border: 1px solid black;
    overflow-y: auto; /* ✅ Enables scrolling */
    margin: 10px auto;
    text-align: left;
    padding: 5px;
    background-color: #f0f0f0;
    display: flex;
    flex-direction: column; /* ✅ Ensures messages fill height */
}

#chatMessages {
    flex-grow: 1; /* ✅ Makes sure messages fill the chatbox */
    overflow-y: auto; /* ✅ Allows scrolling */
}
        /* ✅ Scoreboard Styling */
/* ✅ Scoreboard Styling */
#scoreboard {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: #ffffff;
    border: 2px solid black;
    padding: 10px;
    width: 220px; /* ✅ Slightly wider for better alignment */
    font-size: 14px;
    text-align: center;
}

#scoreboard table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed; /* ✅ Ensure equal column width */
}

#scoreboard th, #scoreboard td {
    border: 1px solid black;
    padding: 5px;
    text-align: center;
    width: 33.33%; /* ✅ Make sure all columns have the same width */
    word-break: break-word; /* ✅ Prevent long names from breaking layout */
}

#scoreboard th {
    background-color: #f2f2f2;
}
        /* ✅ Positioning Buttons Near the Scoreboard */
#returnToMainMenu {
    position: absolute;
    top: 10px;
    left: 250px; /* ✅ Adjusted next to the scoreboard */
    background-color: red;
    color: white;
    padding: 8px 15px;
    border: none;
    cursor: pointer;
}

#forceReturnToWaitingRoom {
    position: absolute;
    top: 50px;
    left: 250px;
    background-color: blue;
    color: white;
    padding: 8px 15px;
    border: none;
    cursor: pointer;
}




    </style>

    <script>
        // ✅ Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB1PPLZl8380-xEpyVX3z8ya9eRji2H-uk",
            authDomain: "upper-2c864.firebaseapp.com",
            databaseURL: "https://upper-2c864-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "upper-2c864",
            storageBucket: "upper-2c864.firebasestorage.app",
            messagingSenderId: "1065732661608",
            appId: "1:1065732661608:web:2db40ab8d60697b34f6dd",
            measurementId: "G-F348XKS47Q"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        var gameCode = ""; 
        var playerName = "";

        function confirmName() {
            playerName = document.getElementById("playerNameInput").value.trim();
            if (playerName === "") {
                alert("Please enter a valid name!");
                return;
            }
            document.getElementById("nameInput").classList.add("hidden");
            document.getElementById("setupArea").classList.remove("hidden");
        }

   

function createGame() {
    gameCode = Math.random().toString(36).substr(2, 6).toUpperCase();
    var totalRounds = document.getElementById("roundsSlider").value;
    var roundTime = document.getElementById("timeSlider").value;

    db.ref("games/" + gameCode).set({
        status: "waiting",
        players: {},
        host: playerName,
        chat: {},
        totalRounds: totalRounds,  // ✅ Store total rounds
        roundTime: roundTime       // ✅ Store time per round
    }).then(() => {
        document.getElementById("gameCodeDisplay").innerText = gameCode;
        document.getElementById("setupArea").classList.add("hidden");
        document.getElementById("gameArea").classList.remove("hidden");
        db.ref("games/" + gameCode + "/players/" + playerName).set(true);
        listenForUpdates();
    });
}


        function joinGame() {
            gameCode = document.getElementById("gameCodeInput").value.toUpperCase();
            if (!gameCode) {
                alert("Please enter a valid game code!");
                return;
            }
            db.ref("games/" + gameCode).get().then(snapshot => {
                if (snapshot.exists()) {
                    document.getElementById("gameCodeDisplay").innerText = gameCode;
                    document.getElementById("setupArea").classList.add("hidden");
                    document.getElementById("gameArea").classList.remove("hidden");
                    db.ref("games/" + gameCode + "/players/" + playerName).set(true);
                    listenForUpdates();
                } else {
                    alert("Game not found!");
                }
            });
        }

    ////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////LISTENFORUPDATE////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
let lastKnownRound = 0;

function listenForUpdates() {
    db.ref("games/" + gameCode).on("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        // 1) Reassign host if the current one is missing
        checkAndReassignHost(gameData);

        console.log("DEBUG: Current host is:", gameData.host);

        // ✅ Update player list in the waiting room
        if (gameData.players) {
            Object.keys(gameData.players).forEach((player) => {
                // Is this player the current host?
                const isHost = (player === gameData.host);

                // If your roles are stored in gameData.roles[player], fetch them safely:
                let role = "unknown";
                if (gameData.roles && gameData.roles[player]) {
                    role = gameData.roles[player];
                }

                console.log(
                    `DEBUG: Player "${player}", role: "${role}", isHost: ${isHost}`
                );
            });

            var playerList = Object.keys(gameData.players)
                .map(name => `<li>${name}</li>`).join("");
            document.getElementById("playerList").innerHTML = `<ul>${playerList}</ul>`;

            // ✅ Ensure sliders are synced with Firebase values
            if (gameData.totalRounds) {
                document.getElementById("roundsSlider").value = gameData.totalRounds;
                document.getElementById("roundsValue").innerText = gameData.totalRounds;
            }
            if (gameData.roundTime) {
                document.getElementById("timeSlider").value = gameData.roundTime;
                document.getElementById("timeValue").innerText = gameData.roundTime;
            }

            // ✅ Attach event listeners to update Firebase when sliders change (Only for the host)
            if (gameData.host === playerName) {
                document.getElementById("timeSlider").addEventListener("input", function() {
                    db.ref("games/" + gameCode).update({ roundTime: this.value });
                });

                document.getElementById("roundsSlider").addEventListener("input", function() {
                    db.ref("games/" + gameCode).update({ totalRounds: this.value });
                });

                document.getElementById("gameSettings").classList.remove("hidden");
                document.getElementById("startGameButton").classList.remove("hidden");
            } else {
                document.getElementById("gameSettings").classList.add("hidden");
                document.getElementById("startGameButton").classList.add("hidden");
            }
        }

        // ✅ Auto-update scoreboard when scores change
        if (gameData.scores) {
            updateScoreboard(gameData.scores);
        }

        // ✅ Chatbox Auto-Scrolling
        if (gameData.chat) {
            const chatBox = document.querySelector(".chatbox");

            // Clear existing messages
            chatBox.innerHTML = "";

            // Add all messages
            Object.values(gameData.chat).forEach(msg => {
                chatBox.innerHTML += `<p>${msg}</p>`;
            });

            // ✅ Ensure chatbox is visible
            chatBox.style.display = "block";

            // ✅ Force scroll to the bottom
            setTimeout(() => {
                chatBox.scrollTop = chatBox.scrollHeight;
            }, 100);
        }

        // ✅ Handle game state: Playing
        if (gameData.status === "playing") {
            document.getElementById("waitingRoom").classList.add("hidden");
            document.getElementById("gameScreen").classList.remove("hidden");

            document.getElementById("gameTerm").innerText = gameData.term;
            document.getElementById("playerRole").innerText = gameData.roles[playerName];

            document.getElementById("currentRoundDisplay").innerText = gameData.currentRound;
            document.getElementById("totalRoundsDisplay").innerText = gameData.totalRounds;

            // Compare rounds to see if we've started a *new* round
            if (gameData.currentRound !== lastKnownRound) {
                lastKnownRound = gameData.currentRound;
                // ✅ Only the host does startCountdown
                if (gameData.host === playerName) {
                    startCountdown(
                        gameData.timeLeft,
                        gameData.currentRound,
                        gameData.totalRounds,
                        gameData.roundTime
                    );
                }
            }

            // ✅ Update time left
            document.getElementById("timeLeftDisplay").innerText = gameData.timeLeft + " seconds";

            // ✅ Hide thinker panel unless needed
            document.getElementById("thinkerPanel").classList.add("hidden");

            // ✅ Show definition only for REALUPPER
            const definitionBox = document.getElementById("correctDefinitionBox");
            const definitionText = document.getElementById("correctDefinition");

            if (definitionBox && definitionText) {
                if (gameData.roles[playerName] === "REALUPPER") {
                    definitionText.innerText = gameData.correctDefinition;
                    definitionBox.classList.remove("hidden");
                } else {
                    definitionBox.classList.add("hidden");
                    definitionText.innerText = "";  // ✅ Clear previous round’s definition
                }
            }

            // ✅ Ensure 9UPPER players don’t see the definition
            const definitionInputBox = document.getElementById("definitionInputBox");
            if (definitionInputBox) {
                if (gameData.roles[playerName] === "9UPPER") {
                    definitionInputBox.classList.remove("hidden");
                } else {
                    definitionInputBox.classList.add("hidden");
                }
            }

            displaythinkerOptions(gameData);

            // ✅ Show "Return to Waiting Room" only for the host
            const returnToWaitingRoomBtn = document.getElementById("forceReturnToWaitingRoom");
            if (returnToWaitingRoomBtn) {
                if (gameData.host === playerName) {
                    returnToWaitingRoomBtn.classList.remove("hidden");
                } else {
                    returnToWaitingRoomBtn.classList.add("hidden");
                }
            }
        }
        // ✅ Add this new block for status === "waiting"
        else if (gameData.status === "waiting") {
            // Hide the game screen, show the waiting room
            document.getElementById("gameScreen").classList.add("hidden");
            document.getElementById("waitingRoom").classList.remove("hidden");

            // Hide the "Return to Waiting Room" button for everyone
            const returnToWaitingRoomBtn = document.getElementById("forceReturnToWaitingRoom");
            if (returnToWaitingRoomBtn) {
                returnToWaitingRoomBtn.classList.add("hidden");
            }
        }
        // Anything else (not playing, not waiting)
        else {
            // If game is NOT playing or waiting, ensure "Return to Waiting Room" is hidden
            const returnToWaitingRoomBtn = document.getElementById("forceReturnToWaitingRoom");
            if (returnToWaitingRoomBtn) {
                returnToWaitingRoomBtn.classList.add("hidden");
            }
        }

        // ✅ Always show "Return to Main Menu" button (for all players)
        const returnToMainMenuBtn = document.getElementById("returnToMainMenu");
        if (returnToMainMenuBtn) {
            returnToMainMenuBtn.classList.remove("hidden");
        }

        // ✅ Handle game end
        if (gameData.status === "finished") {
            // ✅ Immediately set status to something else (like "post-finished")
            db.ref("games/" + gameCode).update({ status: "post-finished" });
            showEndgameScreen(gameData.scores);
        }
    });
}


////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////LISTENFORUPDATE////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
        





        





        var roundTimer; // ✅ Global timer variable


function startCountdown(timeLeft, round, totalRounds, roundTime) {
    // Safeguard against invalid timeLeft
    if (isNaN(timeLeft) || timeLeft === undefined) {
        console.error("Error: timeLeft is NaN or undefined, resetting to 60");
        timeLeft = 60;
    }

    clearInterval(roundTimer);

    // Start a new interval timer for this round
    roundTimer = setInterval(() => {
        if (timeLeft <= 0) {
            // Time’s up—stop the timer
            clearInterval(roundTimer);

            // 1) Set timeLeft = 0 in the database
            db.ref(`games/${gameCode}`).update({ timeLeft: 0 }).then(() => {
                // 2) Fetch the latest game data to see if the thinker picked a winner
                db.ref(`games/${gameCode}`).once("value", snapshot => {
                    const gameData = snapshot.val();
                    if (!gameData) return;

                    const winner = gameData.winner || null;
                    const roles = gameData.roles || {};
                    const collectSkins = Array.isArray(gameData.collectSkins) 
                        ? gameData.collectSkins 
                        : [];
                    const scores = gameData.scores || {};

                    const thinker = Object.keys(roles).find(p => roles[p] === "thinker");
                    const realUpper = Object.keys(roles).find(p => roles[p] === "REALUPPER");

                    console.log("DEBUG partial scoring:", {
  winner, 
  thinker,
  realUpper,
  collectSkins
});


                    // 3) If there's no winner yet, apply partial scoring for Collect Skin
                    if (!winner && thinker && realUpper && collectSkins.length > 0) {
                        const collectSkinMessages = [];

                        collectSkins.forEach(target => {
                            if (target === realUpper) {
                                // The thinker collected from REALUPPER by mistake
                                scores[thinker] = (scores[thinker] || 0) - 1;
                                collectSkinMessages.push(
                                    `Thinker tried to collect from REALUPPER (${target}) ⇒ Thinker -1`
                                );
                            } else {
                                // Target is presumably a 9UPPER
                                scores[thinker] = (scores[thinker] || 0) + 1;
                                scores[target] = (scores[target] || 0) - 1;
                                collectSkinMessages.push(
                                    `Thinker collected skin from 9UPPER (${target}) ⇒ Thinker +1, ${target} -1`
                                );
                            }
                        });

                        // Push all the Collect Skin results to the chat
                        collectSkinMessages.forEach(msg => {
                            db.ref(`games/${gameCode}/chat`).push(msg);
                        });

                        // Final “time’s up” reveal
                        db.ref(`games/${gameCode}/chat`).push(
                            `Time's up! Thinker did not pick anyone. REALUPPER was "${realUpper}".`
                        );

                        // Update the DB with partial scoring and reset collectSkins
                        db.ref(`games/${gameCode}`).update({
                            scores: scores,
                            collectSkins: []
                        }).then(() => {
                            // Update local scoreboard
                            updateScoreboard(scores);
                        });
                    } 
                    else if (!winner && thinker && realUpper) {
                        // No Collect Skin attempts, but no winner picked either
                        db.ref(`games/${gameCode}/chat`).push(
                            `Time's up! No pick made. REALUPPER was "${realUpper}".`
                        );
                    }

                    // 4) Move to next round or end the game if it's the final round
                    if (round >= totalRounds) {
                        endRound(round, totalRounds);
                    } else {
                        const nextRound = (gameData.currentRound || 0) + 1;
                        fetch("9upper_terms.json")
                            .then(response => response.json())
                            .then(terms => {
                                startNewRound(
                                    terms, 
                                    nextRound, 
                                    totalRounds, 
                                    roundTime
                                );
                            });
                    }
                });
            });

        } else {
            // Decrement time and update DB
            timeLeft--;
            db.ref(`games/${gameCode}`).update({ timeLeft });

            // Show updated time in the UI
            document.getElementById("timeLeftDisplay").innerText = `${timeLeft} seconds`;
        }
    }, 1000);
}







        

function displaythinkerOptions(gameData) {
    var thinker = Object.keys(gameData.players).find(p => gameData.roles[p] === "thinker");
    var playerRole = gameData.roles[playerName];

    if (playerRole === "thinker") {
        document.getElementById("thinkerPanel").classList.remove("hidden");

        var selectablePlayers = Object.keys(gameData.players).filter(p => p !== thinker);

        // Row 1: "Pick: [player1] [player2] ..."
        const pickButtons = selectablePlayers.map(player => {
            return `<button onclick="thinkerSelectPlayer('${player}')">
                        ${player}
                    </button>`;
        }).join(" ");

        // Row 2: "Collect Skin: [player1] [player2] ..."
        const collectSkinButtons = selectablePlayers.map(player => {
            return `<button onclick="thinkerCollectSkin('${player}')">
                        ${player}
                    </button>`;
        }).join(" ");

        // Add them to thinkerOptions in two distinct lines/rows
        document.getElementById("thinkerOptions").innerHTML = `
            <div style="margin-bottom: 8px;">
                <strong>Pick:</strong> ${pickButtons}
            </div>
            <div>
                <strong>Collect Skin:</strong> ${collectSkinButtons}
            </div>
        `;
    } else {
        // Hide panel if not thinker
        document.getElementById("thinkerPanel").classList.add("hidden");
        document.getElementById("thinkerOptions").innerHTML = "";
    }
}










function thinkerSelectPlayer(selectedPlayer) {
    clearInterval(roundTimer);

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        var scores = gameData.scores || {};
        var roles = gameData.roles || {};
        var thinker = Object.keys(roles).find(p => roles[p] === "thinker");
        var realUpper = Object.keys(roles).find(p => roles[p] === "REALUPPER");
        var collectSkins = gameData.collectSkins || [];

        // 1) Apply any collected-skin logic
        collectSkins.forEach(target => {
            if (target === realUpper) {
                // If the thinker tried to collect from the REALUPPER
                scores[thinker] = (scores[thinker] || 0) - 1;
            } else {
                // Otherwise, target is presumably a 9UPPER
                scores[thinker] = (scores[thinker] || 0) + 1;
                scores[target]   = (scores[target]   || 0) - 1;
            }
        });

        // 2) Apply the final pick logic
        let message = "";
        if (selectedPlayer === realUpper) {
            scores[thinker]   = (scores[thinker]   || 0) + 1;
            scores[realUpper] = (scores[realUpper] || 0) + 1;
            message = `Thinker picked ${realUpper}, which is correct! (Thinker & REALUPPER both +1)`;
        } else {
            scores[selectedPlayer] = (scores[selectedPlayer] || 0) + 1;
            message = `Thinker guessed wrong! REALUPPER was "${realUpper}".`;
        }

        // 3) Push the final pick message to chat so everyone sees it
        db.ref("games/" + gameCode + "/chat").push(message);

        // 4) Update DB: new scores, set winner, clear collectSkins, end the round
        db.ref("games/" + gameCode).update({
            scores: scores,
            winner: selectedPlayer,
            timeLeft: 0,
            collectSkins: [] // Clear for next round
        }).then(() => {
            updateScoreboard(scores);
        });

        // 5) Either move to next round or end game
        db.ref("games/" + gameCode + "/currentRound").once("value", roundSnapshot => {
            var round = roundSnapshot.val();
            db.ref("games/" + gameCode + "/totalRounds").once("value", totalSnapshot => {
                var totalRounds = totalSnapshot.val();

                if (round >= totalRounds) {
                    endRound(round, totalRounds);
                } else {
                    fetch("9upper_terms.json")
                        .then(response => response.json())
                        .then(terms => {
                            startNewRound(terms, round + 1, totalRounds, gameData.roundTime);
                        });
                }
            });
        });
    });
}










function startGame() {
    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        var totalRounds = gameData.totalRounds;
        var roundTime = gameData.roundTime;

        fetch("9upper_terms.json")
            .then(response => response.json())
            .then(terms => {
                db.ref("games/" + gameCode + "/players").once("value", playerSnapshot => {
                    var players = Object.keys(playerSnapshot.val());
                    if (players.length < 3) {
                        alert("At least 3 players are needed to start the game!");
                        return;
                    }

                    var thinker = players[Math.floor(Math.random() * players.length)];
                    var correctPlayer = players.filter(p => p !== thinker)[Math.floor(Math.random() * (players.length - 1))];

                    var roles = {};
                    players.forEach(p => roles[p] = "9UPPER");
                    roles[thinker] = "thinker";
                    roles[correctPlayer] = "REALUPPER";

                    var randomIndex = Math.floor(Math.random() * terms.length);
                    var randomTerm = terms[randomIndex].term;
                    var correctDefinition = terms[randomIndex].definition;

                    // ✅ Initialize scores for all players
                    var initialScores = {};
                    players.forEach(p => initialScores[p] = 0); 

                    db.ref("games/" + gameCode).update({
                        status: "playing",
                        term: randomTerm,
                        correctDefinition: correctDefinition,
                        roles: roles,
                        currentRound: 1,
                        totalRounds: totalRounds,
                        roundTime: roundTime,
                        scores: initialScores // ✅ Store initial scores in Firebase
                    });

                    // // ✅ Send a chat message announcing the thinker
                    // db.ref("games/" + gameCode + "/chat").push(
                    //     `Round 1, player ${thinker} is the thinker.`
                    // );
                    
                    startNewRound(terms, 1, totalRounds, roundTime);
                });
            })
            .catch(error => console.error("Error loading terms:", error));
    });
}

        var roundTimer;

function startNewRound(terms, round, totalRounds, roundTime) {
    // ✅ Ensure roundTime is always valid
    if (isNaN(roundTime) || roundTime === undefined) {
        console.error("Error: roundTime is NaN or undefined, resetting to 60");
        roundTime = 60;  // ✅ Default to 60 seconds if undefined
    }

    // ✅ Ensure round is a valid number
    if (isNaN(round) || round === undefined) {
        console.error("Error: round is NaN or undefined, resetting to 1");
        round = 1;
    }

    db.ref("games/" + gameCode + "/players").once("value", snapshot => {
        var players = Object.keys(snapshot.val() || {});
        if (players.length < 3) return;

        var thinker = players[Math.floor(Math.random() * players.length)];
        var correctPlayer = players.filter(p => p !== thinker)[Math.floor(Math.random() * (players.length - 1))];

        var roles = {};
        players.forEach(p => roles[p] = "9UPPER");
        roles[thinker] = "thinker";
        roles[correctPlayer] = "REALUPPER";

        var randomIndex = Math.floor(Math.random() * terms.length);
        var randomTerm = terms[randomIndex].term;
        var correctDefinition = terms[randomIndex].definition;

        db.ref("games/" + gameCode).update({
            currentRound: round,
            term: randomTerm,
            correctDefinition: "",  // ✅ Reset before assigning a new value
            roles: roles,
            timeLeft: roundTime,  // ✅ Ensure it's always a number
            winner: null, // ✅ Reset winner for new round
            collectSkins: [] // ✅ Always reset collectSkins at the start of a round
        }).then(() => {
            db.ref("games/" + gameCode).update({
                correctDefinition: correctDefinition // ✅ Now set the correct definition for the new REALUPPER
            });
             // ✅ Send a chat message announcing the thinker
            db.ref("games/" + gameCode + "/chat").push(
                `Round ${round}, player ${thinker} is the thinker.`
            );
        });

        var roundDisplay = document.getElementById("currentRoundDisplay");
        if (roundDisplay) {
            roundDisplay.innerText = round;
        }

        startRoundTimer(roundTime, round, totalRounds);
    });
}






function startRoundTimer(roundTime, round, totalRounds) {
    clearInterval(roundTimer); // ✅ Stop any existing timer

    db.ref("games/" + gameCode).update({ timeLeft: roundTime }); // ✅ Ensure Firebase starts at the right time

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        if (playerName === gameData.host) {  // ✅ Only the host updates Firebase
            roundTimer = setInterval(() => {
                db.ref("games/" + gameCode).once("value", snapshot => {
                    var gameData = snapshot.val();
                    if (!gameData) return;

                    var timeLeft = gameData.timeLeft || 0;

                    if (timeLeft <= 0) {  
                        // clearInterval(roundTimer);
                        // if (!gameData.winner) {  
                        //     db.ref("games/" + gameCode).update({ winner: "timeout" }); // ✅ Mark timeout
                        // }
                        endRound(round, totalRounds); // ✅ Start next round
                    } else {
                        db.ref("games/" + gameCode).update({ timeLeft: timeLeft - 1 });
                    }
                });
            }, 1000);
        }
    });
}






function endRound(round, totalRounds) {
    clearInterval(roundTimer); // Stop any running timer

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        // 1) Copy the old round data so we can apply partial scoring correctly
        var oldRoles = { ...gameData.roles };
        var oldCollectSkins = Array.isArray(gameData.collectSkins) ? [...gameData.collectSkins] : [];
        var oldScores = { ...gameData.scores };
        var winner = gameData.winner || null; 
        var roundTime = gameData.roundTime;

        // Identify the roles in the old data (not the new round!)
        var thinker = Object.keys(oldRoles).find(p => oldRoles[p] === "thinker");
        var realUpper = Object.keys(oldRoles).find(p => oldRoles[p] === "REALUPPER");

        // 2) If the thinker never picked (time ran out), apply partial scoring from collectSkin
        if (!winner && thinker && realUpper && oldCollectSkins.length > 0) {
            // We'll build up a small summary to push to chat
            let collectSkinMessages = [];

            oldCollectSkins.forEach(target => {
                if (target === realUpper) {
                    // The thinker tried to collect from REALUPPER
                    oldScores[thinker] = (oldScores[thinker] || 0) - 1;
                    collectSkinMessages.push(
                        `Thinker tried to collect from REALUPPER (${target}) ⇒ Thinker -1`
                    );
                } else {
                    // The target is presumably a 9UPPER
                    oldScores[thinker] = (oldScores[thinker] || 0) + 1;
                    oldScores[target] = (oldScores[target] || 0) - 1;
                    collectSkinMessages.push(
                        `Thinker collected skin from 9UPPER (${target}) ⇒ Thinker +1, ${target} -1`
                    );
                }
            });

            // Push the detailed breakdown to chat
            collectSkinMessages.forEach(msg => {
                db.ref(`games/${gameCode}/chat`).push(msg);
            });

            // Finally, push a "time's up" reveal message
            db.ref(`games/${gameCode}/chat`).push(
                `Time's up! Thinker did not pick anyone. REALUPPER was "${realUpper}".`
            );

            // Apply updated scores & clear collectSkins
            db.ref(`games/${gameCode}`).update({
                scores: oldScores,
                collectSkins: []
            });
        } 
        else if (!winner && thinker && realUpper) {
            // If there's no winner but also no collectSkins, just reveal the REALUPPER
            db.ref(`games/${gameCode}/chat`).push(
                `Time's up! No pick made. REALUPPER was "${realUpper}".`
            );
        }

        // 3) Move to next round or finish
        if (round >= totalRounds) {
            // Mark the game as finished
            db.ref(`games/${gameCode}`).update({ status: "finished" });
        } else {
            fetch("9upper_terms.json")
                .then(response => response.json())
                .then(terms => {
                    // IMPORTANT: only now do we reset roles/winner for the new round
                    db.ref(`games/${gameCode}`).update({
                        term: "",
                        correctDefinition: "",
                        roles: {},
                        winner: null,
                        timeLeft: roundTime
                    }).then(() => {
                        startNewRound(terms, round + 1, totalRounds, roundTime);
                    });
                });
        }
    });
}










function sendChatMessage() {
    var message = $("#chatInput").val().trim(); // ✅ Use jQuery for input field
    if (message === "") return;

    db.ref("games/" + gameCode + "/chat").push(playerName + ": " + message).then(() => {
        var chatBox = $("#chatMessages"); // ✅ Use jQuery for chatbox

        // ✅ Smooth auto-scroll using jQuery
        chatBox.animate({
            scrollTop: chatBox.prop("scrollHeight")  // ✅ Correct usage
        }, 1000);
    });

    $("#chatInput").val(""); // ✅ Clear input field using jQuery
}




function updateRounds() {
    document.getElementById("roundsValue").innerText = document.getElementById("roundsSlider").value;
}

function updateTime() {
    document.getElementById("timeValue").innerText = document.getElementById("timeSlider").value;
}

   function updateScoreboard(scores) {
    var scoreboardBody = document.getElementById("scoreboardBody");
    scoreboardBody.innerHTML = ""; // Clear current scoreboard

    // Convert scores object into an array and sort by score (descending)
    var sortedPlayers = Object.entries(scores).sort((a, b) => b[1] - a[1]);

    sortedPlayers.forEach((player, index) => {
        var row = `<tr>
            <td>${index + 1}</td>
            <td style="max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${player[0]}</td>
            <td>${player[1]}</td>
        </tr>`;
        scoreboardBody.innerHTML += row;
    });
}


  // ✅ Global timer variable
var roundTimer;


        function handleGameEnd() {
    db.ref("games/" + gameCode).update({ status: "finished" });
}


function showEndgameScreen(scores) {
    // ✅ If the endGameModal already exists, do nothing
    if (document.getElementById("endGameModal")) {
        console.log("Endgame screen already shown. Not firing again.");
        return;
    }
  // ✅ Hide Game Settings & Start Game button for everyone
    const gameSettingsDiv = document.getElementById("gameSettings");
    const startGameBtn = document.getElementById("startGameButton");
    if (gameSettingsDiv) {
        gameSettingsDiv.classList.add("hidden");
    }
    if (startGameBtn) {
        startGameBtn.classList.add("hidden");
    }
    
    var endGameModal = document.createElement("div");
    endGameModal.id = "endGameModal";
    endGameModal.style.position = "fixed";
    endGameModal.style.top = "50%";
    endGameModal.style.left = "50%";
    endGameModal.style.transform = "translate(-50%, -50%)";
    endGameModal.style.background = "white";
    endGameModal.style.padding = "20px";
    endGameModal.style.borderRadius = "10px";
    endGameModal.style.boxShadow = "0 0 10px rgba(0,0,0,0.3)";
    endGameModal.style.textAlign = "center";

    var sortedScores = Object.entries(scores).sort((a, b) => b[1] - a[1]);

    var scoreHTML = `<h2>Game Over!</h2><h3>Final Scores</h3>
        <table border="1" style="margin:auto;">
        <tr><th>Rank</th><th>Player</th><th>Score</th></tr>`;

    sortedScores.forEach((player, index) => {
        scoreHTML += `<tr><td>${index + 1}</td><td>${player[0]}</td><td>${player[1]}</td></tr>`;
    });

    scoreHTML += `</table><br>`;

    endGameModal.innerHTML = scoreHTML + `
        <button onclick="returnToWaitingRoom()" style="background:blue;color:white;padding:10px;border:none;margin:5px;">Back to Waiting Room</button>
        <button onclick="returnToMainMenu()" style="background:red;color:white;padding:10px;border:none;margin:5px;">Back to Main Menu</button>
    `;

    document.body.appendChild(endGameModal);


    // Remove players from the waiting room when the game ends
    db.ref("games/" + gameCode + "/players").once("value", snapshot => {
        var players = snapshot.val();
        if (players) {
            Object.keys(players).forEach(player => {
                db.ref("games/" + gameCode + "/players/" + player).remove();
            });
        }
    });
}








function returnToWaitingRoom() {
    // ✅ Check if the modal exists before removing
    document.getElementById("endGameModal").remove();

    // ✅ Hide Game Screen & Show Waiting Room
    document.getElementById("gameScreen").classList.add("hidden");
    document.getElementById("waitingRoom").classList.remove("hidden");

    // ✅ Update Firebase: Set game status to "waiting"
    db.ref("games/" + gameCode).update({ status: "waiting" });

    // ✅ Re-add the player to the waiting room
    db.ref("games/" + gameCode + "/players/" + playerName).set(true);
}






function returnToMainMenu() {
    // If the endGameModal is on the screen, remove it.
    const endGameModal = document.getElementById("endGameModal");
    if (endGameModal) {
        endGameModal.remove();
    }

    // Remove the current player from the game so they don’t stay in the “players” list.
    db.ref("games/" + gameCode + "/players/" + playerName).remove();

    // Reload the page to show the main menu (index.html, for instance).
    window.location.reload();
}


function forceReturnToWaitingRoom() {
  console.log("Forcing all players back to the waiting room...");

  // Update game status to waiting
  db.ref("games/" + gameCode).update({ status: "waiting" });


  // Host immediately hides the game UI
  document.getElementById("gameScreen").classList.add("hidden");
  document.getElementById("waitingRoom").classList.remove("hidden");

  // Hide the button
  document.getElementById("forceReturnToWaitingRoom").classList.add("hidden");
}


function thinkerCollectSkin(selectedPlayer) {
    // 1) Push a message to chat so everyone sees what's happening
    db.ref("games/" + gameCode + "/chat").push(
        `Thinker is collecting skin from "${selectedPlayer}" ...`
    );

    // 2) Record the selectedPlayer in collectSkins, so we apply points at round end or final pick
    db.ref("games/" + gameCode + "/collectSkins").once("value", snapshot => {
        let collectSkins = snapshot.val() || [];
        if (!Array.isArray(collectSkins)) collectSkins = [];
        collectSkins.push(selectedPlayer);

        db.ref("games/" + gameCode).update({
            collectSkins: collectSkins
        });
    });
}

 function checkAndReassignHost(gameData) {
    if (!gameData.players) return;
    const allPlayers = Object.keys(gameData.players);
    if (allPlayers.length === 0) return;

    // If the current host is still valid, do nothing
    if (allPlayers.includes(gameData.host)) {
        return;
    }

    // Host is missing: find who *should* become host
    allPlayers.sort();
    const newHost = allPlayers[0]; // e.g. first alphabetical

    // ✅ Only that newHost's own client actually writes to the DB
    if (playerName === newHost) {
        const oldHost = gameData.host; // Might be "" or null
        db.ref(`games/${gameCode}`).update({ host: newHost });

        // And only *this* client pushes the chat message
        db.ref(`games/${gameCode}/chat`).push(
            `The old host was missing, so "${newHost}" is now the new host. (Old was "${oldHost}")`
        );
    }
}




    </script>
</head>
<body>
    <h1>9upper Online Multiplayer</h1>

    <div id="nameInput">
        <input type="text" id="playerNameInput" placeholder="Enter Your Name">
        <button onclick="confirmName()">Continue</button>
    </div>

    <div id="setupArea" class="hidden">
        <button onclick="createGame()">Create Game</button>
        <input type="text" id="gameCodeInput" placeholder="Enter Game Code">
        <button onclick="joinGame()">Join Game</button>
    </div>

    <div id="gameArea" class="hidden">
        <h2>Game Code: <span id="gameCodeDisplay"></span></h2>

        <div id="waitingRoom">
            <h2>Players in Room</h2>
            <div id="playerList"></div>
<!-- ✅ Game Settings for Host -->
<div id="gameSettings" class="hidden">
    <h3>Game Settings</h3>

<label for="roundsSlider">Rounds: <span id="roundsValue">5</span></label>
<input type="range" id="roundsSlider" min="5" max="20" step="5" value="5" oninput="updateRounds()">

<br>

<label for="timeSlider">Time per Round (seconds): <span id="timeValue">60</span></label>
<input type="range" id="timeSlider" min="10" max="600" step="10" value="60" oninput="updateTime()">
</div>

            <button id="startGameButton" class="hidden" onclick="startGame()">Start Game</button>
        </div>

<!-- ✅ Scoreboard Display -->
<div id="scoreboard">
    <h3>Scoreboard</h3>
    <table>
        <thead>
            <tr>
                <th>Rank</th>
                <th>Player</th>
                <th>Score</th>
            </tr>
        </thead>
        <tbody id="scoreboardBody">
            <!-- Scores will be dynamically inserted here -->
        </tbody>
    </table>
</div>

        
        
<div id="gameScreen" class="hidden">
    <h3>Round <span id="currentRoundDisplay"></span> / <span id="totalRoundsDisplay"></span></h3>
    <h3>Time Remaining: <span id="timeLeftDisplay">--</span></h3>
    <h3>Term: <span id="gameTerm"></span></h3>
    <h3>Your Role: <span id="playerRole"></span></h3>

    <div id="correctDefinitionBox" class="hidden">
        <h3>REALUPPER: <span id="correctDefinition"></span></h3>
    </div>

    <div id="thinkerPanel" class="hidden">
        <h3>thinker: Pick the correct player</h3>
        <div id="thinkerOptions"></div>
    </div>
</div>





        <!-- ✅ Chatbox Added -->
        <div class="chatbox">
            <div id="chatMessages"></div>
        </div>
        <input type="text" id="chatInput" placeholder="Type a message">
        <button onclick="sendChatMessage()">Send</button>

        <!-- ✅ Scoreboard Display with New Buttons -->
<div id="scoreboard">
    <h3>Scoreboard</h3>
    <table>
        <thead>
            <tr>
                <th>Rank</th>
                <th>Player</th>
                <th>Score</th>
            </tr>
        </thead>
        <tbody id="scoreboardBody">
            <!-- Scores will be dynamically inserted here -->
        </tbody>
    </table>
</div>

<!-- ✅ Return to Main Menu Button (Visible to Everyone) -->
<button id="returnToMainMenu" onclick="returnToMainMenu()">Return to Main Menu</button>

<!-- ✅ Force Return to Waiting Room (Only for Host) -->
<button id="forceReturnToWaitingRoom" class="hidden" onclick="forceReturnToWaitingRoom()">Return to Waiting Room</button>


    </div>

    
</body>
</html>
