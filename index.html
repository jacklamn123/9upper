<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>9upper Online</title>

    <!-- ✅ Firebase Scripts -->
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-app.js"></script>
    <script src="https://www.gstatic.com/firebasejs/8.10.1/firebase-database.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js"></script>

    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
        }
        .hidden {
            display: none;
        }
        .chatbox {
    width: 300px;
    height: 200px;
    border: 1px solid black;
    overflow-y: auto; /* ✅ Enables scrolling */
    margin: 10px auto;
    text-align: left;
    padding: 5px;
    background-color: #f0f0f0;
    display: flex;
    flex-direction: column; /* ✅ Ensures messages fill height */
}

#chatMessages {
    flex-grow: 1; /* ✅ Makes sure messages fill the chatbox */
    overflow-y: auto; /* ✅ Allows scrolling */
}
        /* ✅ Scoreboard Styling */
/* ✅ Scoreboard Styling */
#scoreboard {
    position: absolute;
    top: 10px;
    left: 10px;
    background-color: #ffffff;
    border: 2px solid black;
    padding: 10px;
    width: 220px; /* ✅ Slightly wider for better alignment */
    font-size: 14px;
    text-align: center;
}

#scoreboard table {
    width: 100%;
    border-collapse: collapse;
    table-layout: fixed; /* ✅ Ensure equal column width */
}

#scoreboard th, #scoreboard td {
    border: 1px solid black;
    padding: 5px;
    text-align: center;
    width: 33.33%; /* ✅ Make sure all columns have the same width */
    word-break: break-word; /* ✅ Prevent long names from breaking layout */
}

#scoreboard th {
    background-color: #f2f2f2;
}



    </style>

    <script>
        // ✅ Firebase Configuration
        const firebaseConfig = {
            apiKey: "AIzaSyB1PPLZl8380-xEpyVX3z8ya9eRji2H-uk",
            authDomain: "upper-2c864.firebaseapp.com",
            databaseURL: "https://upper-2c864-default-rtdb.asia-southeast1.firebasedatabase.app",
            projectId: "upper-2c864",
            storageBucket: "upper-2c864.firebasestorage.app",
            messagingSenderId: "1065732661608",
            appId: "1:1065732661608:web:2db40ab8d60697b34f6dd",
            measurementId: "G-F348XKS47Q"
        };

        firebase.initializeApp(firebaseConfig);
        const db = firebase.database();

        var gameCode = ""; 
        var playerName = "";

        function confirmName() {
            playerName = document.getElementById("playerNameInput").value.trim();
            if (playerName === "") {
                alert("Please enter a valid name!");
                return;
            }
            document.getElementById("nameInput").classList.add("hidden");
            document.getElementById("setupArea").classList.remove("hidden");
        }

   

function createGame() {
    gameCode = Math.random().toString(36).substr(2, 6).toUpperCase();
    var totalRounds = document.getElementById("roundsSlider").value;
    var roundTime = document.getElementById("timeSlider").value;

    db.ref("games/" + gameCode).set({
        status: "waiting",
        players: {},
        host: playerName,
        chat: {},
        totalRounds: totalRounds,  // ✅ Store total rounds
        roundTime: roundTime       // ✅ Store time per round
    }).then(() => {
        document.getElementById("gameCodeDisplay").innerText = gameCode;
        document.getElementById("setupArea").classList.add("hidden");
        document.getElementById("gameArea").classList.remove("hidden");
        db.ref("games/" + gameCode + "/players/" + playerName).set(true);
        listenForUpdates();
    });
}


        function joinGame() {
            gameCode = document.getElementById("gameCodeInput").value.toUpperCase();
            if (!gameCode) {
                alert("Please enter a valid game code!");
                return;
            }
            db.ref("games/" + gameCode).get().then(snapshot => {
                if (snapshot.exists()) {
                    document.getElementById("gameCodeDisplay").innerText = gameCode;
                    document.getElementById("setupArea").classList.add("hidden");
                    document.getElementById("gameArea").classList.remove("hidden");
                    db.ref("games/" + gameCode + "/players/" + playerName).set(true);
                    listenForUpdates();
                } else {
                    alert("Game not found!");
                }
            });
        }

function listenForUpdates() {
    db.ref("games/" + gameCode).on("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        // ✅ Update the player list in the waiting room
        if (gameData.waitingPlayers) {
            var waitingListHTML = gameData.waitingPlayers.map(name => `<li>${name}</li>`).join("");
            document.getElementById("waitingPlayerList").innerHTML = `<ul>${waitingListHTML}</ul>`;
        }

        // ✅ Update the main player list (players currently in the game)
        if (gameData.players) {
            var playerListHTML = Object.keys(gameData.players)
                .map(name => `<li>${name}</li>`).join("");
            document.getElementById("playerList").innerHTML = `<ul>${playerListHTML}</ul>`;
        }

        // ✅ Ensure the game settings & start button are only visible to the host
        if (gameData.host === playerName) {
            document.getElementById("gameSettings").classList.remove("hidden");
            document.getElementById("startGameButton").classList.remove("hidden");
        } else {
            document.getElementById("gameSettings").classList.add("hidden");
            document.getElementById("startGameButton").classList.add("hidden");
        }

        // ✅ Auto-update scoreboard for all players
        if (gameData.scores) {
            updateScoreboard(gameData.scores);
        }

        // ✅ Handle chatbox auto-scrolling
        if (gameData.chat) {
            const chatBox = document.querySelector(".chatbox");
            chatBox.innerHTML = "";

            Object.values(gameData.chat).forEach(msg => {
                chatBox.innerHTML += `<p>${msg}</p>`;
            });

            // ✅ Ensure chatbox is visible and scrolls properly
            chatBox.style.display = "block";
            setTimeout(() => {
                chatBox.scrollTop = chatBox.scrollHeight;
            }, 100);
        }

        // ✅ If game is in progress, hide waiting room and show game screen
        if (gameData.status === "playing") {
            document.getElementById("waitingRoom").classList.add("hidden");
            document.getElementById("gameScreen").classList.remove("hidden");

            document.getElementById("gameTerm").innerText = gameData.term;
            document.getElementById("playerRole").innerText = gameData.roles[playerName];

            document.getElementById("currentRoundDisplay").innerText = gameData.currentRound;
            document.getElementById("totalRoundsDisplay").innerText = gameData.totalRounds;

            // ✅ Ensure all players see the correct countdown time from Firebase
            document.getElementById("timeLeftDisplay").innerText = gameData.timeLeft + " seconds";

            // ✅ Only the host controls the countdown timer, but all players see the updated time
            if (gameData.host === playerName) {
                startCountdown(gameData.timeLeft, gameData.currentRound, gameData.totalRounds, gameData.roundTime);
            }

            document.getElementById("thinkerPanel").classList.add("hidden");

            // ✅ Ensure REALUPPER sees the correct definition, while others don't
            const definitionBox = document.getElementById("correctDefinitionBox");
            const definitionText = document.getElementById("correctDefinition");

            if (definitionBox && definitionText) {
                if (gameData.roles[playerName] === "REALUPPER") {
                    definitionText.innerText = gameData.correctDefinition;
                    definitionBox.classList.remove("hidden");
                } else {
                    definitionBox.classList.add("hidden");
                    definitionText.innerText = "";
                }
            }

            // ✅ Hide/show definition input based on roles
            const definitionInputBox = document.getElementById("definitionInputBox");
            if (definitionInputBox) {
                if (gameData.roles[playerName] === "9UPPER") {
                    definitionInputBox.classList.remove("hidden");
                } else {
                    definitionInputBox.classList.add("hidden");
                }
            }

            displaythinkerOptions(gameData);
        }

        // ✅ If game has ended, show final scoreboard to ALL players
        if (gameData.status === "finished") {
            showEndgameScreen(gameData.scores);
        }
    });
}




        var roundTimer; // ✅ Global timer variable

function startCountdown(timeLeft, round, totalRounds, roundTime) {
    if (isNaN(timeLeft) || timeLeft === undefined) {
        console.error("Error: timeLeft is NaN or undefined, resetting to 60");
        timeLeft = 60;
    }

    clearInterval(roundTimer);

    roundTimer = setInterval(() => {
        if (timeLeft <= 0) {
            clearInterval(roundTimer);
            db.ref("games/" + gameCode).update({ timeLeft: 0 });

            if (round >= totalRounds) {
                endRound(round, totalRounds);
            } else {
                db.ref("games/" + gameCode).once("value", snapshot => {
                    var gameData = snapshot.val();
                    if (!gameData) return;

                    var nextRound = (gameData.currentRound || 0) + 1;
                    fetch("9upper_terms.json")
                        .then(response => response.json())
                        .then(terms => {
                            startNewRound(terms, nextRound, totalRounds, roundTime);
                        });
                });
            }
        } else {
            timeLeft--;
            db.ref("games/" + gameCode).update({ timeLeft: timeLeft });

            document.getElementById("timeLeftDisplay").innerText = timeLeft + " seconds";
        }
    }, 1000);
}





        
function displaythinkerOptions(gameData) {
    var thinker = Object.keys(gameData.players).find(p => gameData.roles[p] === "thinker");
    var playerRole = gameData.roles[playerName];

    if (playerRole === "thinker") {
        // ✅ Show thinker panel only if the player is the thinker
        document.getElementById("thinkerPanel").classList.remove("hidden");

        var selectablePlayers = Object.keys(gameData.players).filter(p => p !== thinker);

        var buttonsHTML = selectablePlayers.map(player =>
            `<button onclick="thinkerSelectPlayer('${player}')">${player}</button>`
        ).join(" ");

        document.getElementById("thinkerOptions").innerHTML = buttonsHTML;
    } 
    else if (playerRole === "REALUPPER" || playerRole === "9UPPER") {
        // ✅ Explicitly hide panel for REALUPPER & 9UPPER players
        document.getElementById("thinkerPanel").classList.add("hidden");
        document.getElementById("thinkerOptions").innerHTML = ""; // Clear buttons
    }
}







function thinkerSelectPlayer(selectedPlayer) {
    clearInterval(roundTimer);

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        var scores = gameData.scores || {};
        var roles = gameData.roles || {};
        var thinker = Object.keys(roles).find(p => roles[p] === "thinker");
        var realUpper = Object.keys(roles).find(p => roles[p] === "REALUPPER");

        if (selectedPlayer === realUpper) {
            scores[thinker] = (scores[thinker] || 0) + 1;
            scores[realUpper] = (scores[realUpper] || 0) + 1;
        } else {
            scores[selectedPlayer] = (scores[selectedPlayer] || 0) + 1;
        }

        db.ref("games/" + gameCode).update({
            scores: scores,
            winner: selectedPlayer,
            timeLeft: 0
        }).then(() => {
            updateScoreboard(scores);
        });

        db.ref("games/" + gameCode + "/currentRound").once("value", snapshot => {
            var round = snapshot.val();
            db.ref("games/" + gameCode + "/totalRounds").once("value", totalSnapshot => {
                var totalRounds = totalSnapshot.val();

                if (round >= totalRounds) {
                    endRound(round, totalRounds);
                } else {
                    fetch("9upper_terms.json")
                        .then(response => response.json())
                        .then(terms => {
                            startNewRound(terms, round + 1, totalRounds, gameData.roundTime);
                        });
                }
            });
        });
    });
}








function startGame() {
    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        var totalRounds = gameData.totalRounds || 5;  // ✅ Ensure totalRounds has a fallback
        var roundTime = gameData.roundTime || 60;     // ✅ Ensure roundTime has a fallback

        db.ref("games/" + gameCode + "/waitingPlayers").once("value", playerSnapshot => {
            var waitingPlayers = playerSnapshot.val() || {};
            var players = Object.keys(waitingPlayers);  // ✅ Use only players who are in waiting room

            console.log("Players in waiting room:", players);  // ✅ Debugging log

            if (players.length < 3) {
                alert("At least 3 players are needed to start the game!");
                return;
            }

            // ✅ Randomly assign roles
            var thinker = players[Math.floor(Math.random() * players.length)];
            var correctPlayer = players.filter(p => p !== thinker)[Math.floor(Math.random() * (players.length - 1))];

            var roles = {};
            players.forEach(p => roles[p] = "9UPPER");
            roles[thinker] = "thinker";
            roles[correctPlayer] = "REALUPPER";

            // ✅ Pick a random term for the round
            fetch("9upper_terms.json")
                .then(response => response.json())
                .then(terms => {
                    var randomIndex = Math.floor(Math.random() * terms.length);
                    var randomTerm = terms[randomIndex].term;
                    var correctDefinition = terms[randomIndex].definition;

                    // ✅ Initialize scores for all active players
                    var initialScores = {};
                    players.forEach(p => initialScores[p] = 0);

                    // ✅ Clear previous game data & start new game
                    db.ref("games/" + gameCode).update({
                        status: "playing",
                        players: waitingPlayers,  // ✅ Move waiting players to active game
                        term: randomTerm,
                        correctDefinition: correctDefinition,
                        roles: roles,
                        currentRound: 1,
                        totalRounds: totalRounds,
                        roundTime: roundTime,
                        scores: initialScores,
                        waitingPlayers: {}  // ✅ Clear waiting room once game starts
                    });

                    // ✅ Start the first round
                    startNewRound(terms, 1, totalRounds, roundTime);
                })
                .catch(error => console.error("Error loading terms:", error));
        });
    });
}


        

          var roundTimer;

function startNewRound(terms, round, totalRounds, roundTime) {
    // ✅ Ensure roundTime is always valid
    if (isNaN(roundTime) || roundTime === undefined) {
        console.error("Error: roundTime is NaN or undefined, resetting to 60");
        roundTime = 60;  // ✅ Default to 60 seconds if undefined
    }

    // ✅ Ensure round is a valid number
    if (isNaN(round) || round === undefined) {
        console.error("Error: round is NaN or undefined, resetting to 1");
        round = 1;
    }

    db.ref("games/" + gameCode + "/players").once("value", snapshot => {
        var players = Object.keys(snapshot.val() || {});
        if (players.length < 3) return;

        var thinker = players[Math.floor(Math.random() * players.length)];
        var correctPlayer = players.filter(p => p !== thinker)[Math.floor(Math.random() * (players.length - 1))];

        var roles = {};
        players.forEach(p => roles[p] = "9UPPER");
        roles[thinker] = "thinker";
        roles[correctPlayer] = "REALUPPER";

        var randomIndex = Math.floor(Math.random() * terms.length);
        var randomTerm = terms[randomIndex].term;
        var correctDefinition = terms[randomIndex].definition;

        db.ref("games/" + gameCode).update({
            currentRound: round,
            term: randomTerm,
            correctDefinition: "",  // ✅ Reset before assigning a new value
            roles: roles,
            timeLeft: roundTime  // ✅ Ensure it's always a number
        }).then(() => {
            db.ref("games/" + gameCode).update({
                correctDefinition: correctDefinition // ✅ Now set the correct definition for the new REALUPPER
            });
        });

        var roundDisplay = document.getElementById("currentRoundDisplay");
        if (roundDisplay) {
            roundDisplay.innerText = round;
        }

        startRoundTimer(roundTime, round, totalRounds);
    });
}






function startRoundTimer(roundTime, round, totalRounds) {
    clearInterval(roundTimer); // ✅ Stop any existing timer

    db.ref("games/" + gameCode).update({ timeLeft: roundTime }); // ✅ Ensure Firebase starts at the right time

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        if (playerName === gameData.host) {  // ✅ Only the host updates Firebase
            roundTimer = setInterval(() => {
                db.ref("games/" + gameCode).once("value", snapshot => {
                    var gameData = snapshot.val();
                    if (!gameData) return;

                    var timeLeft = gameData.timeLeft || 0;

                    if (timeLeft <= 0) {  
                        clearInterval(roundTimer);
                        if (!gameData.winner) {  
                            db.ref("games/" + gameCode).update({ winner: "timeout" }); // ✅ Mark timeout
                        }
                        endRound(round, totalRounds); // ✅ Start next round
                    } else {
                        db.ref("games/" + gameCode).update({ timeLeft: timeLeft - 1 });
                    }
                });
            }, 1000);
        }
    });
}






function endRound(round, totalRounds) {
    clearInterval(roundTimer); // ✅ Stop any running timer

    db.ref("games/" + gameCode).once("value", snapshot => {
        var gameData = snapshot.val();
        if (!gameData) return;

        var roundTime = gameData.roundTime; // ✅ Fetch roundTime before calling startNewRound()

        if (round >= totalRounds) {
            db.ref("games/" + gameCode).update({ status: "finished" });

            // ✅ Ensure all players receive the endgame screen
            showEndgameScreen(gameData.scores);
        } else {
            fetch("9upper_terms.json")
                .then(response => response.json())
                .then(terms => {
                    db.ref("games/" + gameCode).update({
                        term: "",
                        correctDefinition: "",
                        roles: {},
                        winner: null,
                        timeLeft: roundTime
                    }).then(() => {
                        startNewRound(terms, round + 1, totalRounds, roundTime);
                    });
                });
        }
    });
}








function sendChatMessage() {
    var message = $("#chatInput").val().trim(); // ✅ Use jQuery for input field
    if (message === "") return;

    db.ref("games/" + gameCode + "/chat").push(playerName + ": " + message).then(() => {
        var chatBox = $("#chatMessages"); // ✅ Use jQuery for chatbox

        // ✅ Smooth auto-scroll using jQuery
        chatBox.animate({
            scrollTop: chatBox.prop("scrollHeight")  // ✅ Correct usage
        }, 1000);
    });

    $("#chatInput").val(""); // ✅ Clear input field using jQuery
}




function updateRounds() {
    document.getElementById("roundsValue").innerText = document.getElementById("roundsSlider").value;
}

function updateTime() {
    document.getElementById("timeValue").innerText = document.getElementById("timeSlider").value;
}

   function updateScoreboard(scores) {
    var scoreboardBody = document.getElementById("scoreboardBody");
    scoreboardBody.innerHTML = ""; // Clear current scoreboard

    // Convert scores object into an array and sort by score (descending)
    var sortedPlayers = Object.entries(scores).sort((a, b) => b[1] - a[1]);

    sortedPlayers.forEach((player, index) => {
        var row = `<tr>
            <td>${index + 1}</td>
            <td style="max-width: 70px; overflow: hidden; text-overflow: ellipsis; white-space: nowrap;">${player[0]}</td>
            <td>${player[1]}</td>
        </tr>`;
        scoreboardBody.innerHTML += row;
    });
}


  // ✅ Global timer variable
var roundTimer;

// ✅ Function to handle when the game is over
function handleGameEnd() {
    db.ref("games/" + gameCode).update({ status: "finished" }).then(() => {
        showFinalScoreboard();
    });
}

function showEndgameScreen(scores) {
    var endGameModal = document.createElement("div");
    endGameModal.id = "endGameModal";
    endGameModal.style.position = "fixed";
    endGameModal.style.top = "50%";
    endGameModal.style.left = "50%";
    endGameModal.style.transform = "translate(-50%, -50%)";
    endGameModal.style.background = "white";
    endGameModal.style.padding = "20px";
    endGameModal.style.borderRadius = "10px";
    endGameModal.style.boxShadow = "0 0 10px rgba(0,0,0,0.3)";
    endGameModal.style.textAlign = "center";

    var sortedScores = Object.entries(scores).sort((a, b) => b[1] - a[1]);

    var scoreHTML = `<h2>Game Over!</h2><h3>Final Scores</h3><table border="1" style="margin:auto;">
        <tr><th>Rank</th><th>Player</th><th>Score</th></tr>`;

    sortedScores.forEach((player, index) => {
        scoreHTML += `<tr><td>${index + 1}</td><td>${player[0]}</td><td>${player[1]}</td></tr>`;
    });

    scoreHTML += `</table><br>`;

    endGameModal.innerHTML = scoreHTML + `
        <button onclick="returnToWaitingRoom()" style="background:blue;color:white;padding:10px;border:none;margin:5px;">
            Back to Waiting Room
        </button>
        <button onclick="returnToMainMenu()" style="background:red;color:white;padding:10px;border:none;margin:5px;">
            Exit to Main Menu
        </button>
    `;

    document.body.appendChild(endGameModal);
}



function restartGame() {
    document.getElementById("endGameModal").remove();
    startGame();
}


function returnToMainMenu() {
    document.getElementById("endGameModal").remove();

    db.ref("games/" + gameCode + "/players/" + playerName).remove(); // ✅ Remove from game players
    db.ref("games/" + gameCode + "/waitingPlayers").once("value", snapshot => {
        var waitingPlayers = snapshot.val() || [];
        var updatedWaitingPlayers = waitingPlayers.filter(p => p !== playerName);

        db.ref("games/" + gameCode).update({
            waitingPlayers: updatedWaitingPlayers
        });
    });

    window.location.reload(); // ✅ Reloads page to go back to main menu
}


function returnToWaitingRoom() {
    document.getElementById("endGameModal").remove();

    db.ref("games/" + gameCode + "/waitingPlayers").once("value", snapshot => {
        var waitingPlayers = snapshot.val() || [];

        if (!waitingPlayers.includes(playerName)) {
            waitingPlayers.push(playerName); // ✅ Add player to waiting room
        }

        db.ref("games/" + gameCode).update({
            waitingPlayers: waitingPlayers
        });

        // ✅ Hide game screen, show waiting room UI
        document.getElementById("gameScreen").classList.add("hidden");
        document.getElementById("waitingRoom").classList.remove("hidden");
    });
}



        
    </script>
</head>
<body>
    <h1>9upper Online Multiplayer</h1>

    <div id="nameInput">
        <input type="text" id="playerNameInput" placeholder="Enter Your Name">
        <button onclick="confirmName()">Continue</button>
    </div>

    <div id="setupArea" class="hidden">
        <button onclick="createGame()">Create Game</button>
        <input type="text" id="gameCodeInput" placeholder="Enter Game Code">
        <button onclick="joinGame()">Join Game</button>
    </div>

    <div id="gameArea" class="hidden">
        <h2>Game Code: <span id="gameCodeDisplay"></span></h2>

        <div id="waitingRoom">
            <h2>Players in Room</h2>
            <div id="playerList"></div>
<!-- ✅ Game Settings for Host -->
<div id="gameSettings" class="hidden">
    <h3>Game Settings</h3>

    <label for="roundsSlider">Rounds: <span id="roundsValue">5</span></label>
    <input type="range" id="roundsSlider" min="5" max="20" step="5" value="5" oninput="updateRounds()">

    <br>

    <label for="timeSlider">Time per Round (seconds): <span id="timeValue">60</span></label>
    <input type="range" id="timeSlider" min="60" max="600" step="30" value="60" oninput="updateTime()">
</div>

            <button id="startGameButton" class="hidden" onclick="startGame()">Start Game</button>
        </div>

<!-- ✅ Scoreboard Display -->
<div id="scoreboard">
    <h3>Scoreboard</h3>
    <table>
        <thead>
            <tr>
                <th>Rank</th>
                <th>Player</th>
                <th>Score</th>
            </tr>
        </thead>
        <tbody id="scoreboardBody">
            <!-- Scores will be dynamically inserted here -->
        </tbody>
    </table>
</div>

        
        
<div id="gameScreen" class="hidden">
    <h3>Round <span id="currentRoundDisplay"></span> / <span id="totalRoundsDisplay"></span></h3>
    <h3>Time Remaining: <span id="timeLeftDisplay">--</span></h3>
    <h3>Term: <span id="gameTerm"></span></h3>
    <h3>Your Role: <span id="playerRole"></span></h3>

    <div id="correctDefinitionBox" class="hidden">
        <h3>REALUPPER: <span id="correctDefinition"></span></h3>
    </div>

    <div id="thinkerPanel" class="hidden">
        <h3>thinker: Pick the correct player</h3>
        <div id="thinkerOptions"></div>
    </div>
</div>





        <!-- ✅ Chatbox Added -->
        <div class="chatbox">
            <div id="chatMessages"></div>
        </div>
        <input type="text" id="chatInput" placeholder="Type a message">
        <button onclick="sendChatMessage()">Send</button>

    </div>
</body>
</html>
